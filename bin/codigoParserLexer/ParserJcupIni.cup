package ParserLexer;
import java_cup.runtime.*;

// Tabla de símbolos
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;

action code {:

    // Definición del HashMap
    HashMap<String, ArrayList<String>> listaTablaSimbolos = new HashMap<String, ArrayList<String>>();
    String currentHash;
     
    // Función para imprimir la tabla de símbolos
    public void imprimirTablaSimbolos(){
        for (String key: listaTablaSimbolos.keySet()){
            System.out.println("Tabla de simbolo: " + key);
            System.out.println("La tabla contiene estos valores: ");
            for(String item: listaTablaSimbolos.get(key)){
                System.out.println(item);
            }
            System.out.println("");
        }
    }

    // Agarra el tipo del token en la tabla de símbolos
    public String getTipo(ArrayList<String> tablasSimbolos, String id){
        String tipo = "null";
        for(String token : tablasSimbolos){
            String[] partesToken = token.split(":");
            if(id.equals(partesToken[2])){
                tipo = partesToken[3];
            }
        }
        System.out.println("tipo: "+tipo);
        return tipo;
    }
:}

parser code {:
    //Conectar parser a un escaner
    LexerJflex lex;

    @SuppressWarnings(value = { "deprecation" })
    public parser(LexerJflex lex){
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }

    //Manejo de errores
    public void syntax_error(Symbol cur_token) {
    System.err.println("Error sintáctico en la línea " + (cur_token.left+1) + 
                       ", columna " + (cur_token.right));
    }
    
    //Errores no recuperables
    public void unrecovered_syntax_error(Symbol cur_token) {
        if (cur_token.sym == sym.EOF) {
            System.err.println("Se alcanzó el final del archivo.");
        } else {
            System.err.println("Error de sintaxis irrecuperable en la línea " + (cur_token.left + 1) + 
                            ", columna " + (cur_token.right + 1) + ". Análisis abortado.");
        }
    }
:}

init with {: :};
scan with {: return lex.next_token(); :};

/* Lexer navideño */
terminal            EMPEZONAVIDAD, FESTIVAL, FIESTA, PERSONA, l_SANTA , l_SANTA_CLAUS, l_PAPANOEL, l_PASCUERO, l_COLACHO, ENTREGA, ELFO1, ELFO2, ELFO3, ELFO4, ELFO5, ELFO6;
terminal            GRINCH, QUIEN, RODOLFO, COMETA, BAILARIN, CUPIDO, DONNER, DASHER, ELFO, HADA, DUENDE, ENVUELVE, ENVOLTURA, HACE, REVISA, ENVIA, CORTA, MELCHOR, GASPAR, BALTASAR, POLO;
terminal            ABRECUENTO, CIERRACUENTO, ABREEMPAQUE, CIERRAEMPAQUE, ABREREGALO, CIERRAREGALO, FINREGALO, SANTACLAUS, PAPANOEL, SANNICOLAS, SINTERKLASS, VIEJITOPASCUERO, COLACHO;
terminal            ENTREGAREGALOS, MUERDAGO, NARRA, ESCUCHA, SANTACLAUSULA;

/* No terminales */
non terminal            poloNorte, t_navidad, t_santas, literales_navidenios, literal_no_nums, literal_nums, bolsanavidenia, pNocheBuena, pbolsanavideniaAux, narraNavidad, escuchaNavidad, entregaRegalos;
non terminal            grinchYQuien, unidadNavidenia, logisticadeNavidad, reyesMagos, regalo, cuerpo, ayudanteDeSanta, ayudaDefFunNav, definirFunNav, corta;
non terminal            elfos_g, elfos_nums, comp_elfosN, comp_elfosG, regaloprin, creaRegalo, creaRegaloAux;
non terminal            opciones, whileStmt, forStmt, cuerpoMain, regaloExtn, antartica, compN, compG, doWhileStmt, envia, elfoStm, hadaStm, duendeStm, renos;
non terminal            decl_G, llamadaNavidenia, llamadaNavideniaAux, ids, accesoArray, arrayDeclaration, arrayInitialization, listaExpresiones;

//Precedence
precedence left RODOLFO,COMETA;
precedence left BAILARIN,CUPIDO;
precedence left DONNER,DASHER;
precedence left ABRECUENTO, ELFO1, ELFO2, ELFO3, ELFO4, ELFO5, ELFO6, GRINCH, QUIEN, MELCHOR, GASPAR, BALTASAR;
precedence left FINREGALO, CIERRACUENTO;


/* Inicio */
start with entregaRegalos;

//Grupos de literales
literales_navidenios ::= l_SANTA:lst {:RESULT = lst + "int";:} 
                    | l_SANTA_CLAUS:lst {:RESULT = lst + "bool";:} 
                    | l_PAPANOEL:lst {:RESULT = lst + "string";:} 
                    | l_PASCUERO:lst {:RESULT = lst + "float";:} 
                    | l_COLACHO:lst {:RESULT = lst + "char";:};

literal_nums ::= l_SANTA:lst {:RESULT = lst + "int";:} 
            | l_PASCUERO:lst {:RESULT = lst + "float";:};

literal_no_nums ::= l_SANTA_CLAUS:lst {:RESULT = lst + "bool";:} 
                | l_PAPANOEL:lst {:RESULT = lst + "string";:};

//Operadores unarios
unidadNavidenia ::= GRINCH | QUIEN;
opciones ::= literales_navidenios:lst | PERSONA:per;
grinchYQuien ::= unidadNavidenia opciones;

//Operadores logicos
logisticadeNavidad ::= MELCHOR | GASPAR;
reyesMagos ::= opciones logisticadeNavidad opciones
                | BALTASAR opciones;

//Print
narraNavidad ::= NARRA ABRECUENTO regaloprin CIERRACUENTO FINREGALO;

//read
escuchaNavidad ::= ESCUCHA ABRECUENTO regaloprin CIERRACUENTO FINREGALO;

//Tipos
t_santas ::= SANTACLAUS:tst {:RESULT = tst;:} 
            | PAPANOEL:tst {:RESULT = tst;:} 
            | SANNICOLAS:tst {:RESULT = tst;:}
            | SINTERKLASS:tst {:RESULT = tst;:} 
            | VIEJITOPASCUERO:tst {:RESULT = tst;:} 
            | COLACHO:tst {:RESULT = tst;:}
            | SANTACLAUSULA:tst {:RESULT = tst;:};

//public o private
t_navidad ::= FESTIVAL | FIESTA;

//return
envia ::= ENVIA regaloprin FINREGALO;

//Break
corta ::= CORTA FINREGALO;

// Operadores generales: ==, !=
elfos_g ::= ELFO1:elf | ELFO2:elf;

// Operadores relacionales: >, <, =>, =<
elfos_nums ::= ELFO3:elf | ELFO4:elf | ELFO5:elf | ELFO6:elf;

// Regla que ayuda a las operaciones relacionales
compN ::= literal_nums:lst
        | PERSONA:per 
        ;

// Operaciones relacionales que sólo permiten enteros o flotantes(>, <, >= <_)  
comp_elfosN ::= compN:operR1 elfos_nums:elf compN:operR2;




// Regla que ayuda a las operaciones generales 
compG ::= literales_navidenios:lst
        {:
        String[] partesOperando = lst.toString().split(":");
        if (partesOperando[1].equals("int") || partesOperando[1].equals("float")  || partesOperando[1].equals("bool")){
            RESULT = "dir:" + partesOperando[1]; //Esto es para la generación de código destino que se ocupa la dirección, no sé qué más hacer.
            System.out.println("Acá entró y funcionó la validación general 1111"); 
        }else{
            RESULT = "dir:null";
            System.out.println("Error semántico en la línea "+ (cur_token.left+1) + 
                       ", columna " + (cur_token.right) + " tipo no permitido del literal " + partesOperando[1]);
       }
       :}
        | PERSONA:per 
        {:
        ArrayList<String> ts = listaTablaSimbolos.get(currentHash);
        String tipoId = getTipo(ts,per.toString());
        if (tipoId.equals("int") || tipoId.equals("float")|| tipoId.equals("bool")){
            RESULT = "dir:"+tipoId; //Esto es para la generación de código destino (Mips) que se ocupa la dirección, no sé qué más hacer.
            System.out.println("Acá entró y funcionó la validación general 222");
        }else{
            RESULT = "dir:null";
            System.out.println("Error semántico en la línea "+ (cur_token.left+1) + 
                       ", columna " + (cur_token.right) + "tipo no permitido del id " + per);
       }
       :}
        ;

//Comparaciones generales(==, !=) y sólo permiten enteros, flotantes y booleanos
comp_elfosG ::= compG:opcomg1 elfos_g:elf compG:opcomg2{:
        String[] partesOperando_comp_elfosG = opcomg1.toString().split(":");
        String[] partesOperando_comp_elfosG1 = opcomg2.toString().split(":");

        if(partesOperando_comp_elfosG[1].equals(partesOperando_comp_elfosG1[1]) && !(partesOperando_comp_elfosG[1].equals("null") || partesOperando_comp_elfosG1[1].equals("null"))){
            // Generación código Mips
            RESULT = "dir:"+ partesOperando_comp_elfosG[1];
        }
        else
        {
            System.out.println("Los tipos de los operandos: " + partesOperando_comp_elfosG[0] + "y" + partesOperando_comp_elfosG1[0] + "no son iguales");
        }   
        RESULT = "dir:null";
       :}
       ;


// Operadores aritméticos -, +, *, /, ~, **
renos ::= COMETA:rn    {:RESULT = rn;:}
         | RODOLFO:rn  {:RESULT = rn;:} 
         | BAILARIN:rn {:RESULT = rn;:} 
         | CUPIDO:rn   {:RESULT = rn;:} 
         | DONNER:rn   {:RESULT = rn;:} 
         | DASHER:rn   {:RESULT = rn;:};


// Operaciones aritméticas
regaloprin ::= COMETA regaloprin
       | BALTASAR regaloprin
       | regaloprin renos:rn regaloprin
       | ABRECUENTO regaloprin CIERRACUENTO
       | literales_navidenios:lst 
       /*{:
       String [] partesOperando = lst.toString().split(":");
       if (partesOperando[1].equals("int") || partesOperando[1].equals("float")){
        RESULT = "dir:"+partesOperando[1]; //Esto es para la generación de código destino que se ocupa la dirección, no sé qué más hacer. 
       }else{
        RESULT = "dir:null";
        System.out.println("Error semántico en la línea "+ (cur_token.left+1) + 
                       ", columna " + (cur_token.right) + "tipo no permitido del literal " + partesOperando[0]);
       }
       :}*/

       | regaloprin logisticadeNavidad regaloprin
       | regaloprin unidadNavidenia regaloprin
       | regaloprin elfos_g regaloprin
       | regaloprin elfos_nums regaloprin
       | accesoArray
       | llamadaNavideniaAux
       | llamadaNavidenia
       | PERSONA:per
       /*{:
       ArrayList<String> ts = listaTablaSimbolos.get(currentHash);
       String tipoId = getTipo(ts,per.toString());
       if (tipoId.equals("int") || tipoId.equals("float")){
        RESULT = "dir:"+partesOperando[1]; //Esto es para la generación de código destino que se ocupa la dirección, no sé qué más hacer.
        System.out.println("Acá entró"); 
       }else{
        RESULT = "dir:null";
        System.out.println("Error semántico en la línea "+ (cur_token.left+1) + 
                       ", columna " + (cur_token.right) + "tipo no permitido del id " + per);
       }
       :}*/
       ;


//Declaracion de variables

//redeclaracion de datos ejemplo:
//num = 0|
decl_G ::= PERSONA ENTREGA regaloprin FINREGALO
        ;


//declaracion de variables simplificado
//local int x <= 6
creaRegaloAux ::= POLO t_santas:tst PERSONA:per
                {:
                if (!listaTablaSimbolos.containsKey(currentHash)) {
                listaTablaSimbolos.put(currentHash, new ArrayList<String>());
                }
                listaTablaSimbolos.get(currentHash).add("tipo:Local:" + per.toString()+":"+ tst.toString());
                :}
                | POLO t_santas:tst PERSONA:per ENTREGA regaloprin
                {:
                if (!listaTablaSimbolos.containsKey(currentHash)) {
                listaTablaSimbolos.put(currentHash, new ArrayList<String>());
                }
                listaTablaSimbolos.get(currentHash).add("tipo:Local:" + per.toString()+":"+ tst.toString());
                :}
                | error EMPEZONAVIDAD
                ;

creaRegalo ::= creaRegaloAux FINREGALO;

cuerpo ::= ABREREGALO regalo CIERRAREGALO;


//arrays
//local int arr[3]|
arrayDeclaration ::= POLO t_santas:tst PERSONA ABREEMPAQUE regaloprin CIERRAEMPAQUE FINREGALO
                    | error FINREGALO
                    ;

// Regla de inicialización de arrays
//int arr[3] <= {a,b,3}|
arrayInitialization ::= t_santas:tst PERSONA ABREEMPAQUE regaloprin CIERRAEMPAQUE ENTREGA ABREREGALO listaExpresiones CIERRAREGALO FINREGALO 
                    | error FINREGALO
                    ;


listaExpresiones ::= regaloprin
                 | listaExpresiones MUERDAGO regaloprin;

//Acceso y asignacion array
//arr[1] ó  arr[3] <= 4|
accesoArray ::= PERSONA ABREEMPAQUE regaloprin CIERRAEMPAQUE
            | PERSONA ABREEMPAQUE regaloprin CIERRAEMPAQUE ENTREGA regaloprin FINREGALO;

//Ciclos

//While
//while ( i <_ 5 ){}
whileStmt ::= ENVOLTURA ABRECUENTO comp_elfosN CIERRACUENTO cuerpo
            | ENVOLTURA ABRECUENTO comp_elfosG CIERRACUENTO cuerpo
            | ENVOLTURA ABRECUENTO l_SANTA_CLAUS:lst CIERRACUENTO cuerpo;

//do until (do while)
//do{ cuerpo }until ( i <_ 5 )|
doWhileStmt ::= HACE cuerpo REVISA ABRECUENTO comp_elfosN CIERRACUENTO FINREGALO
                | HACE cuerpo REVISA ABRECUENTO comp_elfosG CIERRACUENTO FINREGALO
                | HACE cuerpo REVISA ABRECUENTO l_SANTA_CLAUS:lst CIERRACUENTO FINREGALO;

//For 
//for(x=2,x<20,++x)
forStmt ::= ENVUELVE ABRECUENTO PERSONA ENTREGA l_SANTA MUERDAGO comp_elfosN MUERDAGO grinchYQuien CIERRACUENTO cuerpo
            | ENVUELVE ABRECUENTO PERSONA ENTREGA l_SANTA MUERDAGO comp_elfosG MUERDAGO grinchYQuien CIERRACUENTO cuerpo
            | ENVUELVE ABRECUENTO PERSONA ENTREGA l_SANTA MUERDAGO l_SANTA_CLAUS MUERDAGO grinchYQuien CIERRACUENTO cuerpo
            | ENVUELVE ABRECUENTO PAPANOEL PERSONA ENTREGA l_SANTA MUERDAGO comp_elfosN MUERDAGO grinchYQuien CIERRACUENTO cuerpo
            | ENVUELVE ABRECUENTO PAPANOEL PERSONA ENTREGA l_SANTA MUERDAGO comp_elfosG MUERDAGO grinchYQuien CIERRACUENTO cuerpo
            | ENVUELVE ABRECUENTO PAPANOEL PERSONA ENTREGA l_SANTA MUERDAGO l_SANTA_CLAUS MUERDAGO grinchYQuien CIERRACUENTO cuerpo
            | ENVUELVE ABRECUENTO POLO PAPANOEL PERSONA ENTREGA regaloprin MUERDAGO comp_elfosN MUERDAGO grinchYQuien CIERRACUENTO cuerpo
            | ENVUELVE ABRECUENTO POLO PAPANOEL PERSONA ENTREGA regaloprin MUERDAGO comp_elfosG MUERDAGO grinchYQuien CIERRACUENTO cuerpo
            | ENVUELVE ABRECUENTO POLO PAPANOEL PERSONA ENTREGA regaloprin MUERDAGO l_SANTA_CLAUS MUERDAGO grinchYQuien CIERRACUENTO cuerpo;

//if - elif - else
//if
elfoStm::= ELFO ABRECUENTO comp_elfosN CIERRACUENTO cuerpo
            | ELFO ABRECUENTO comp_elfosG CIERRACUENTO cuerpo;

//elif
hadaStm::= HADA ABRECUENTO comp_elfosN CIERRACUENTO cuerpo
            | HADA ABRECUENTO comp_elfosG CIERRACUENTO cuerpo;

//else
duendeStm ::= DUENDE cuerpo;


//Funciones 

// Parámetro 
ayudanteDeSanta ::= t_santas:tst PERSONA:per
                {:
                if (!listaTablaSimbolos.containsKey(currentHash)) {
                listaTablaSimbolos.put(currentHash, new ArrayList<String>());
                }
                listaTablaSimbolos.get(currentHash).add("tipo:param:" + per.toString()+":"+ tst.toString());
                :}
                | PERSONA:per
                {:
                if (!listaTablaSimbolos.containsKey(currentHash)) {
                listaTablaSimbolos.put(currentHash, new ArrayList<String>());
                }
                listaTablaSimbolos.get(currentHash).add("tipo:param:" + per.toString());
                :};

// Varios parámetros
ayudaDefFunNav ::= ayudanteDeSanta
                    | ayudaDefFunNav MUERDAGO ayudanteDeSanta;

//Llamada de funciones
//hola|()
//adios|(intx, in)
//error al poner funcion al final de una expresioncon final de linea ocupa doble final de linea para funcionar
ids ::= regaloprin
    | ids MUERDAGO regaloprin;
    
llamadaNavideniaAux ::= PERSONA ABRECUENTO CIERRACUENTO
                  |  PERSONA ABRECUENTO ids CIERRACUENTO;

llamadaNavidenia ::= llamadaNavideniaAux FINREGALO
                  ;


//Definición de funciones
definirFunNav ::= EMPEZONAVIDAD t_santas:tsc PERSONA:per ABRECUENTO CIERRACUENTO 
                /*Se asigna el token seleccionado a su respectiva tabla de símbolos
                En este caso el valor de retorno, el nombre de la función y si es una función main o no*/
                {:
                currentHash = per.toString();
                String tipoTabla = "main";
                if (per.toString().equals("main"))
                        tipoTabla = "tipo:main:"+tsc.toString();
                else
                        tipoTabla = "tipo:function:"+tsc.toString();
                ArrayList<String> funcionMain = new ArrayList<String>();
                funcionMain.add(tipoTabla);
                listaTablaSimbolos.put(currentHash, funcionMain);
                
                :}
               
                | EMPEZONAVIDAD t_santas:tsc PERSONA:per ABRECUENTO ayudaDefFunNav CIERRACUENTO 
                {:
                currentHash = per.toString();
                String tipoTabla = "main";
                if (per.toString().equals("main"))
                        tipoTabla = "tipo:main:"+tsc.toString();
                else
                        tipoTabla = "tipo:function:"+tsc.toString();
                ArrayList<String> funcionMain = new ArrayList<String>();;
                funcionMain.add(tipoTabla);
                listaTablaSimbolos.put(currentHash, funcionMain);
                :} 
                | error FINREGALO 
                | error CIERRAREGALO
                | error ABREREGALO
                ;

bolsanavidenia ::= definirFunNav
                | definirFunNav cuerpo;

pbolsanavideniaAux ::=  bolsanavidenia
                    | pbolsanavideniaAux bolsanavidenia;

pNocheBuena ::= pbolsanavideniaAux;


//funcion main
cuerpoMain ::= ABREREGALO regaloExtn CIERRAREGALO;

entregaRegalos ::= {:
                    System.out.println("Empieza el asunto");
                    :} 
                    EMPEZONAVIDAD VIEJITOPASCUERO ENTREGAREGALOS ABRECUENTO CIERRACUENTO cuerpoMain 
                    {:
                    imprimirTablaSimbolos();
                    System.out.println("Termina el asunto");
                    :};

//Encapsula todas las regaloprinesiones para que se puedan colocar dentro de las funciones
poloNorte  ::= narraNavidad 
                | corta 
                | envia 
                | regaloprin 
                | creaRegalo 
                | whileStmt 
                | forStmt 
                | doWhileStmt 
                | elfoStm 
                | hadaStm 
                | duendeStm 
                | decl_G 
                | escuchaNavidad;

//Produccion de expresiones
regalo ::= poloNorte
            | regalo poloNorte;

antartica ::= bolsanavidenia | poloNorte;

regaloExtn ::= antartica
            | regaloExtn antartica;