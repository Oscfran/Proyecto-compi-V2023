package ParserLexer;
import java_cup.runtime.*;

// Tabla de símbolos
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;

action code {:

    // Definición del HashMap
    HashMap<String, ArrayList<String>> listaTablaSimbolos = new HashMap<String, ArrayList<String>>();
    String currentHash;
     
    // Función para imprimir la tabla de símbolos
    public void imprimirTablaSimbolos(){
        for (String key: listaTablaSimbolos.keySet()){  
            System.out.println("\nLa tabla contiene estos valores: ");
            System.out.println("Tabla de simbolo: " + key);
            for(String item: listaTablaSimbolos.get(key)){
                System.out.println(item);
            }
            System.out.println("");
        }
    }

    // Agarra el tipo del token en la tabla de símbolos
    public String getTipo(ArrayList<String> tablasSimbolos, String id){
        String tipo = "null";
        for(String token : tablasSimbolos){
            String[] partesToken = token.split(":");
            if(id.equals(partesToken[2])){
                //System.out.println("Nombre variable:" + partesToken[2]  + " tipo: " + tipo);
                tipo = partesToken[3];
                
            }
        }
        return tipo;
    }
:}

parser code {:
    //Conectar parser a un escaner
    LexerJflex lex;

    @SuppressWarnings(value = { "deprecation" })
    public parser(LexerJflex lex){
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }

    //Manejo de errores
    public void syntax_error(Symbol cur_token) {
    System.err.println("Error sintáctico en la línea " + (cur_token.left+1) + 
                       ", columna " + (cur_token.right));
    }
    
    //Errores no recuperables
    public void unrecovered_syntax_error(Symbol cur_token) {
        if (cur_token.sym == sym.EOF) {
            System.err.println("Se alcanzó el final del archivo.");
        } else {
            System.err.println("Error de sintaxis irrecuperable en la línea " + (cur_token.left + 1) + 
                            ", columna " + (cur_token.right + 1));
        }
    }
:}

init with {: :};
scan with {: return lex.next_token(); :};

/* Lexer navideño */
terminal            EMPEZONAVIDAD, PERSONA, l_SANTA , l_SANTA_CLAUS, l_PAPANOEL, l_PASCUERO, l_COLACHO, ENTREGA, ELFO1, ELFO2, ELFO3, ELFO4, ELFO5, ELFO6;
terminal            GRINCH, QUIEN, RODOLFO, COMETA, BAILARIN, CUPIDO, DONNER, DASHER, ELFO, HADA, DUENDE, ENVUELVE, ENVOLTURA, HACE, REVISA, ENVIA, CORTA, MELCHOR, GASPAR, BALTASAR, POLO;
terminal            ABRECUENTO, CIERRACUENTO, ABREEMPAQUE, CIERRAEMPAQUE, ABREREGALO, CIERRAREGALO, FINREGALO, SANTACLAUS, PAPANOEL, SANNICOLAS, SINTERKLASS, VIEJITOPASCUERO, COLACHO;
terminal            ENTREGAREGALOS, MUERDAGO, NARRA, ESCUCHA, SANTACLAUSULA, CUPIENTERO, GALLETAQUIETA;

/* No terminales */
non terminal            poloNorte, navidad,t_santas, literales_navidenios, bolsanavidenia, pbolsanavideniaAux, narraNavidad, escuchaNavidad, entregaRegalos;
non terminal            grinchYQuien, unidadNavidenia, logisticadeNavidad, regalo, cuerpo, ayudanteDeSanta, ayudaDefFunNav, definirFunNav, corta;
non terminal            elfos, creaRegalo, estructura, exprUni, exprP, regaloprin, regaloCompradoLogRel, regaloCompradoAux, regaloManualAux, operando, operandoLog;
non terminal            opciones,creaRegaloAssign, forStmt, cuerpoMain, regaloExtn, antartica, doUntilStmt, envia, elfoStm, hadaStm, hadaMulti, duendeStm, renos;
non terminal            decl_G, ayudaDefinirFuncionNavi, llamadaNavidenia, llamadaNavideniaAux, ids, accesoArray, arrayDeclaration, arrayInitialization, listaExpresiones;

//Precedence
precedence left RODOLFO, COMETA;
precedence left BAILARIN, CUPIDO, CUPIENTERO;
precedence left DONNER, DASHER;
precedence left QUIEN, GRINCH;

precedence left ELFO1,
                ELFO2,
                ELFO3,
                ELFO4,
                ELFO5,
                ELFO6;

precedence left MELCHOR;
precedence left GASPAR;
precedence left BALTASAR;

/* Inicio */
start with navidad;

//Grupos de literales
literales_navidenios ::= l_SANTA:lst {:RESULT = lst + ":int";:} 
                    | l_SANTA_CLAUS:lst {:RESULT = lst + ":bool";:} 
                    | l_PAPANOEL:lst {:RESULT = lst + ":string";:} 
                    | l_PASCUERO:lst {:RESULT = lst + ":float";:} 
                    | l_COLACHO:lst {:RESULT = lst + ":char";:};

//Tipos
t_santas ::= SANTACLAUS:tst {:RESULT = tst;:}       //string,
            | PAPANOEL:tst {:RESULT = tst;:}        //int
            | SANNICOLAS:tst {:RESULT = tst;:}      //float
            | SINTERKLASS:tst {:RESULT = tst;:}     //double
            | VIEJITOPASCUERO:tst {:RESULT = tst;:} //void
            | COLACHO:tst {:RESULT = tst;:}         //char
            | SANTACLAUSULA:tst {:RESULT = tst;:};  //bool

// Operadores de comparación
elfos ::= ELFO1:elf {:RESULT = elf;:}// ==
        | ELFO2:elf {:RESULT = elf;:}// !=
        | ELFO3:elf {:RESULT = elf;:}// >
        | ELFO4:elf {:RESULT = elf;:}// <
        | ELFO5:elf {:RESULT = elf;:}// =>
        | ELFO6:elf {:RESULT = elf;:};// =<

// Operadores aritméticos
renos ::= COMETA:rn    {:RESULT = rn;:} // -
         | CUPIENTERO:rn {:RESULT = rn;:} // // Esta es la que puse para la divisón entera/Así da shift reduce
         | RODOLFO:rn  {:RESULT = rn;:} // +
         | BAILARIN:rn {:RESULT = rn;:} // *
         | CUPIDO:rn   {:RESULT = rn;:} // /
         | DONNER:rn   {:RESULT = rn;:} // ~
         | DASHER:rn   {:RESULT = rn;:}; // **

//Operadores unarios
unidadNavidenia ::= GRINCH:gr {:RESULT = gr;:} //++
                 | QUIEN:qn {:RESULT = qn;:}; //--

// Permite expresiones sin declaración (siempre dentro de la función)
exprUni ::= exprP:pr FINREGALO
            {:
            String[] partesOperando = pr.toString().split(":");
                if(!(partesOperando[1].equals("null"))){
                    RESULT = "dir:"+ partesOperando[1];
                }
                else{
                    RESULT = "dir:null";
                } 
            :}
            | grinchYQuien:gr FINREGALO
            {:
            String[] partesOperando = gr.toString().split(":");
                if(!(partesOperando[1].equals("null"))){
                    RESULT = "dir:"+ partesOperando[1];
                }
                else{
                    RESULT = "dir:null";
                } 
            :}
            ;

// Expresión que junta operaciones aritméticas, las relaciones
exprP ::= regaloprin:prin
        {:
            String[] partesOperando = prin.toString().split(":");
            if(!(partesOperando[1].equals("null"))){
                RESULT = "dir:"+ partesOperando[1];
            }else{
                RESULT = "dir:null";
            }
        :} 
        | regaloCompradoLogRel:prlog
        {:  
            //System.out.println("prlog es: "+prlog);
            String[] partesOperando = prlog.toString().split(":");
            if(prlog != null || !(partesOperando[1].equals("null"))){
                RESULT = "dir:"+partesOperando[1];
            }
            else{
                RESULT = "dir:null";
            }
        :}
        ;

// Operación aritmética
regaloprin ::= COMETA operando:oper3 
            {:
                String[] partesOperando = oper3.toString().split(":");
                if(partesOperando[1].equals("int") || partesOperando[1].equals("float") ){
                    RESULT = "dir:"+partesOperando[1];  
                }else{
                    RESULT = "dir:null";
                }
            :}
            | operando:oper1 renos:rn operando:oper2        
            {:
                String[] partesOperando1 = oper1.toString().split(":");
                String[] partesOperando2 = oper2.toString().split(":");

                if(rn.equals("/")){
                    if(partesOperando1[1].equals(partesOperando2[1])){
                        if(partesOperando1[1].equals("float")){
                            System.out.println("Es división flotante");
                            RESULT = "dir:"+partesOperando1[1];
                        }
                        else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) +
                                ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos no son del tipo permitido: " + partesOperando1[1] + ", " + partesOperando2[1]);
                            RESULT = "dir:null";
                        }
                    }
                    else{
                        System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                            ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos no son iguales: " + partesOperando1[1] + ", " + partesOperando2[1]);
                        RESULT = "dir:null";
                    }
                }   
                else if(rn.equals("//")){
                    if(partesOperando1[1].equals(partesOperando2[1])){
                        if(partesOperando1[1].equals("int")){
                            System.out.println("Es división entera");
                            RESULT = "dir:"+partesOperando1[1];
                        }
                        else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                                ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos no son del tipo permitido: " + partesOperando1[1] + ", " + partesOperando2[1]);
                            RESULT = "dir:null";
                        }
                    }
                    else{
                        System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                            ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos no son iguales: " + partesOperando1[1] + ", " + partesOperando2[1]);
                        RESULT = "dir:null";
                    }
                }
                else{  
                    if(partesOperando1[1].equals(partesOperando2[1])){
                        if(partesOperando1[1].equals("int") || partesOperando1[1].equals("float")){
                                RESULT = "dir:"+partesOperando1[1];
                        }
                        else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                            ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos no son del tipo permitidos \n para las operaciones aritméticas: " + partesOperando1[1] + ", " + partesOperando2[1]);
                            RESULT = "dir:null";
                        }
                    }
                    else{
                        System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                            ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos no son iguales: " + partesOperando1[1] + ", " + partesOperando2[1]);
                        RESULT = "dir:null";
                        }
                    }     
            :}  
              ;



// ++i, ++persona, --persona
grinchYQuien ::= unidadNavidenia operando:oper1
            {:
            String[] partesOperando = oper1.toString().split(":");
            if(partesOperando[1].equals("int")){
                RESULT = "dir:"+partesOperando[1];  
            }else{
                RESULT = "dir:null";
                System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                            ", columna " + (cur_token.right) +": "  + "El tipo para su unario no es correcto");
                        RESULT = "dir:null";
            }
            :}
            ;


//Expresiones relacionales
regaloCompradoAux ::= operando:oper1 elfos:elf operando:oper2
            {:
            String[] partesOperando1 = oper1.toString().split(":");
            String[] partesOperando2 = oper2.toString().split(":");
                // Permite expresiones relacionales (==, !=) del mismo tipo, mientras que sean int, float y bool
                if((elf.equals("==") || elf.equals("!="))){
                    if (partesOperando1[1].equals(partesOperando2[1])){
                        //System.out.println("Los tipos de los operadores == y != son los mismos");
                        if ((partesOperando1[1].equals("int")|| partesOperando1[1].equals("float")|| partesOperando1[1].equals("bool"))){
                            //System.out.println("Los tipos int, float y bool son permitidos");
                            RESULT = "dir:"+partesOperando1[1];
                        }
                        else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                                ", columna " + (cur_token.right) +": "  + "Los tipos de los operando no son permitidos, sólo int-float-bool: ");
                                 RESULT = "dir:null";
                        }
                    }
                    else{
                        System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                        ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos relacionales no son iguales: " + partesOperando1[1] + ", " + partesOperando2[1]);
                        RESULT = "dir:null";
                    }
                }
                // Permite expresiones relacionales (<, >, =>, =<) del mismo tipo, mientras que sean int y float
                else{
                    if (partesOperando1[1].equals(partesOperando2[1])){
                        //System.out.println("Los tipos del resto de operadores relacionales son los mismos");
                        if (partesOperando1[1].equals("int") || partesOperando1[1].equals("float")){
                            //System.out.println("Los tipos int, float son permitidos");
                            RESULT = "dir:"+partesOperando1[1];
                        }
                        else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                                ", columna " + (cur_token.right) +": "  + "Los tipos de los operando no son permitidos i-f: ");
                                 RESULT = "dir:null";
                        }
                    }
                    else{
                        System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                        ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos relacionales no son iguales: " + partesOperando1[1] + ", " + partesOperando2[1]);
                        RESULT = "dir:null";
                    }
                }
            :}
            ;
// Combinación de expresiones lógicas y relacionales
regaloCompradoLogRel ::= regaloCompradoAux:relaux 
            {:
            //System.out.println("relaux es:" +relaux);
            if(relaux != null){
                RESULT = relaux;
            }
            else{
                RESULT = "dir:null";
            }
            :}
            | regaloManualAux:logaux
            {:
            //System.out.println("logaux es:" +logaux);
            if(logaux != null){
                RESULT = logaux;
            }
            else{
                RESULT = "dir:null";
            }
            :}
            ;

//Operadores logicos      # | ^
logisticadeNavidad ::= MELCHOR:mel {:RESULT = mel;:} 
                    | GASPAR:gal {:RESULT = gal;:};

// ! operando y operando # | ^ operando
regaloManualAux ::= BALTASAR operando:oper1
            {:
            String[] partesOperando = oper1.toString().split(":");
            if(oper1 != null || !(partesOperando[1].equals("null"))){
                RESULT = "dir:"+partesOperando[1];
            }
            else{
                RESULT = "dir:null";
            }
            :}
            | operando:oper1 logisticadeNavidad:logis operando:oper2
            {:
            String[] partesOperando1 = oper1.toString().split(":");
            String[] partesOperando2 = oper2.toString().split(":");
                if(partesOperando1[1].equals(partesOperando2[1])){
                    /*System.out.println("Los operandos de esta operación en la línea" + (cur_token.left+1) + 
                     ", columna " + (cur_token.right) +":"+"son del mismo tipo logico");*/
                    RESULT = "dir:"+partesOperando1[1];
                }else{
                    System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                        ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos lógicos no son iguales: " + partesOperando1[1] + ", " + partesOperando2[1]);
                    RESULT = "dir:null";
                }
            :};


// Lo que sea que se vaya a operar más carga del tipo per y literal 
operando ::= PERSONA:per
        {:
            ArrayList<String> ts = listaTablaSimbolos.get(currentHash);
            String tipoId = getTipo(ts,per.toString());
            if(tipoId != "null"){
                RESULT = "dir:"+tipoId;
            }else{
                RESULT = "dir:null";
            }
        :}
        | literales_navidenios:lst 
        {:
            String[] partesOperando = lst.toString().split(":");
            if(partesOperando[1] != "null"){
                RESULT = "dir:"+partesOperando[1]; 
            }else{
                RESULT = "dir:null";
            }
       :}
        | llamadaNavidenia 
        | accesoArray 
        | exprP:pr 
        {:
            //System.out.println("pr es:" +pr);
            String[] partesOperando = pr.toString().split(":");
            if(partesOperando[1] != "null"){
                RESULT = "dir:"+partesOperando[1];  
            }else{
                RESULT = "dir:null";
            }
        :}
        | grinchYQuien:gq
        {:
            //System.out.println("pr es:" +pr);
            String[] partesOperando = gq.toString().split(":");
            if(partesOperando[1] != "null"){
                RESULT = "dir:"+partesOperando[1];  
            }else{
                RESULT = "dir:null";
            }
        :}
        | ABRECUENTO operando:ope CIERRACUENTO
        {:
            //System.out.println("pr es:" +pr);
            String[] partesOperando = ope.toString().split(":");
            if(partesOperando[1] != "null"){
                RESULT = "dir:"+partesOperando[1];  
            }else{
                RESULT = "dir:null";
            }
        :}
        ;

//Declaracion de variable sin asignación
//local tipo arroz|
creaRegalo ::= POLO t_santas:tst PERSONA:per FINREGALO
                {:
                    listaTablaSimbolos.get(currentHash).add("tipo:Local:" + per.toString()+":"+ tst.toString());
                        if(!(tst.equals("null"))){
                            //System.out.println("Bien declarada la variable sin asignación");
                            RESULT = "dir:"+ tst;
                        }else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                            ", columna " + (cur_token.right) + " Mal declarada la variable sin asignación");
                            RESULT = "dir:null";
                        }
                :}
                ;

// Declaración de variable con asignación
//local tipo arroz <= 14|
creaRegaloAssign ::= POLO t_santas:tst PERSONA:per ENTREGA operando:oper1 FINREGALO
                {:
                    listaTablaSimbolos.get(currentHash).add("tipo:Local:" + per.toString()+":"+ tst.toString());
                    String[] partesOperando = oper1.toString().split(":");

                    // Se verifica su tipo de la variable
                        if(!(tst.equals("null"))){
                            //System.out.println("tipo de la variable permitido");
                            if(tst.equals(partesOperando[1])){
                                //System.out.println("La variable coincide con su asignación");
                                RESULT = "dir:"+ tst;
                            }
                            else{
                                System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                ", columna " + (cur_token.right) +":"  + " Tipo de la variable no coincide con su tipo de asignación");
                                RESULT = "dir:null";
                            }
                        }else{
                            System.err.println("Error semántico en la línea " + (cur_token.left) + 
                            ", columna " + (cur_token.right) +":"  + "Tipo de la variable vacía");
                            RESULT = "dir:null";
                        }
                :}

                ;
                
//Redeclaración de variables
decl_G ::= PERSONA ENTREGA operando FINREGALO;

cuerpo ::= ABREREGALO CIERRAREGALO
        | ABREREGALO regalo:reg CIERRAREGALO
        {:
            if(reg != null){
                String[] partesOperando = reg.toString().split(":");
                if(!(partesOperando[1].equals("null"))){
                    RESULT = "dir:"+ partesOperando[1];
                }else{
                    RESULT = "dir:null";
                }
            }
        :}
        ;


// Producción para la declaración inicial del array con |, pueden ser estáticas o no.
//local int arr[3]|
//local char arr[3]|
//local static int array[2]|
//local static char array[2]|
arrayDeclaration ::= POLO t_santas:tst PERSONA:per ABREEMPAQUE l_SANTA:lst CIERRAEMPAQUE FINREGALO
                    {:
                    listaTablaSimbolos.get(currentHash).add("tipo:Local:" + per.toString()+":"+ tst.toString());
                        if(tst.equals("int")|| tst.equals("char")){  
                            RESULT = "dir:"+tst;
                        }
                        else{
                            System.err.println("Error semántico en la línea " + (cur_token.left) + 
                            ", columna " + (cur_token.right) +":"  + "Tipo iniciación de array incorrecto, sólo puede ser de tipo char o int");
                            RESULT = "dir:null";
                        }
                    :}
                    | POLO GALLETAQUIETA:gaie t_santas:tst PERSONA:per ABREEMPAQUE l_SANTA:lst CIERRAEMPAQUE FINREGALO
                    {:
                     listaTablaSimbolos.get(currentHash).add("tipo:Local:" + per.toString()+":"+ tst.toString());
                        if(tst.equals("int")|| tst.equals("char")){  
                            RESULT = "dir:"+tst;
                        }
                        else{
                            System.err.println("Error semántico en la línea " + (cur_token.left) + 
                            ", columna " + (cur_token.right) +":"  + "Tipo iniciación de array incorrecto, sólo puede ser de tipo char o int");
                            RESULT = "dir:null";
                        }
                    :}
                    ;

// Regla de inicialización de arrays
//  local char arr[3] <= {a,b,3}|
//  local int arr[3] <= {45,3,1}|
//  local static char arr[3] <= {a,b,3}|
//  local static int arr[3] <= {45,3,1}|
arrayInitialization ::=  POLO t_santas:tst PERSONA:per ABREEMPAQUE l_SANTA:lst CIERRAEMPAQUE ENTREGA ABREREGALO listaExpresiones:lisexpr CIERRAREGALO FINREGALO
                    {:
                        listaTablaSimbolos.get(currentHash).add("tipo:Local:" + per.toString()+":"+ tst.toString());
                        String[] partesOperando = lisexpr.toString().split(":");
                        if(tst.equals("int")){  
                            if((partesOperando[1].equals("int"))){
                                if(tst.equals(partesOperando[1])){
                                    System.out.println("Tipo de array y contenido dentro de llaves parejo INT");
                                    RESULT = "dir:"+ partesOperando[1];
                                }else{
                                    System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                    ", columna " + (cur_token.right) +":"  + "Tipo de array y contenido dentro de llaves incorrecto");
                                    RESULT = "dir:null";
                                }
                            }else{
                                System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                    ", columna " + (cur_token.right) +":"  + "Tipo de array y contenido dentro de llaves no concuerda");
                                RESULT = "dir:null";
                            }
                        }
                        else if(tst.equals("char")){
                            if((partesOperando[1].equals("char"))){
                                if(tst.equals(partesOperando[1])){
                                    System.out.println("Tipo de array y contenido dentro de llaves parejo CHAR");
                                    RESULT = "dir:"+ partesOperando[1];
                                }else{
                                    System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                    ", columna " + (cur_token.right) +":"  + "Tipo de array y contenido dentro de llaves incorrecto");
                                    RESULT = "dir:null";
                                }
                            }else{
                                System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                    ", columna " + (cur_token.right) +":"  + "Tipo de array y contenido dentro de llaves no concuerda");
                                RESULT = "dir:null";
                            }
                        }
                        else{
                            System.err.println("Error semántico en la línea " + (cur_token.left) + 
                            ", columna " + (cur_token.right) +":"  + "Tipo iniciación de array incorrecto, sólo puede ser de char o int");
                            RESULT = "dir:null";
                        }
                    :} 
                    | POLO GALLETAQUIETA:gaie t_santas:tst PERSONA:per ABREEMPAQUE l_SANTA:lst CIERRAEMPAQUE ENTREGA ABREREGALO listaExpresiones:lisexpr CIERRAREGALO FINREGALO
                    {:
                        listaTablaSimbolos.get(currentHash).add("tipo:Local:" + per.toString()+":"+ tst.toString());
                        String[] partesOperando = lisexpr.toString().split(":");
                        if(tst.equals("int")){  
                            if((partesOperando[1].equals("int"))){
                                if(tst.equals(partesOperando[1])){
                                    RESULT = "dir:"+ partesOperando[1];
                                }else{
                                    System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                    ", columna " + (cur_token.right) +":"  + "Tipo de array y contenido dentro de llaves incorrecto");
                                    RESULT = "dir:null";
                                }
                            }else{
                                System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                    ", columna " + (cur_token.right) +":"  + "Tipo de array y contenido dentro de llaves no concuerda");
                                RESULT = "dir:null";
                            }
                        }
                        else if(tst.equals("char")){
                            if((partesOperando[1].equals("char"))){
                                if(tst.equals(partesOperando[1])){
                                    System.out.println("Tipo de array y contenido dentro de llaves parejo CHAR");
                                    RESULT = "dir:"+ partesOperando[1];
                                }else{
                                    System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                    ", columna " + (cur_token.right) +":"  + "Tipo de array y contenido dentro de llaves incorrecto");
                                    RESULT = "dir:null";
                                }
                            }else{
                                System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                    ", columna " + (cur_token.right) +":"  + "Tipo de array y contenido dentro de llaves no concuerda");
                                RESULT = "dir:null";
                            }
                        }
                        else{
                            System.err.println("Error semántico en la línea " + (cur_token.left) + 
                            ", columna " + (cur_token.right) +":"  + "Tipo iniciación de array incorrecto, sólo puede ser de char o int");
                            RESULT = "dir:null";
                        }
                    :} 
                    ;

// Regla para acompañar la asignación de arrays
listaExpresiones ::= operando:oper1
                {:
                    String[] partesOperando = oper1.toString().split(":");
                    if(partesOperando[1].equals("int")|| partesOperando[1].equals("char")){
                        RESULT = "dir:"+ partesOperando[1];
                    }else{
                        System.err.println("Error semántico en la línea " + (cur_token.left) + 
                            ", columna " + (cur_token.right) +":"  + "No llega cargado de ni de tipo int ni char");
                        RESULT = "dir:null";
                    }
                :}
                 | listaExpresiones:lsexpr MUERDAGO operando:oper2
                 {:
                    String[] partesOperando = oper2.toString().split(":");
                    if(partesOperando[1].equals("int")|| partesOperando[1].equals("char")){
                        RESULT = "dir:"+ partesOperando[1];
                    }else{
                        System.err.println("Error semántico en la línea " + (cur_token.left) + 
                            ", columna " + (cur_token.right) +":"  + "No llega cargado de ni de tipo int ni char");
                        RESULT = "dir:null";
                    }
                 :}
                 ;

//Acceso y asignacion array
//arr[1] ó  arr[3] <= 4|
accesoArray ::= PERSONA:per ABREEMPAQUE operando:oper1 CIERRAEMPAQUE
            | PERSONA:per ABREEMPAQUE operando:oper2 CIERRAEMPAQUE ENTREGA operando:oper3 FINREGALO
            ;

//Ciclos

//do until (do)
//do{ cuerpo }until ( i <_ 5 )|
doUntilStmt ::= HACE cuerpo REVISA ABRECUENTO operando CIERRACUENTO FINREGALO
;

//For 
//for(x=2,x<20,++x)
forStmt ::= ENVUELVE ABRECUENTO PERSONA ENTREGA l_SANTA:lst  MUERDAGO regaloCompradoLogRel MUERDAGO grinchYQuien CIERRACUENTO cuerpo
            | ENVUELVE ABRECUENTO PAPANOEL PERSONA ENTREGA l_SANTA MUERDAGO regaloCompradoLogRel MUERDAGO grinchYQuien CIERRACUENTO cuerpo
            | ENVUELVE ABRECUENTO POLO PAPANOEL PERSONA ENTREGA operando MUERDAGO regaloCompradoLogRel MUERDAGO grinchYQuien CIERRACUENTO cuerpo;

//if - elif - else
//if
elfoStm::= ELFO ABRECUENTO operando:oper1 CIERRACUENTO cuerpo:cuer1
            | ELFO ABRECUENTO operando:oper2 CIERRACUENTO cuerpo:cuer2 duendeStm //if y else
            | ELFO ABRECUENTO operando:oper3 CIERRACUENTO cuerpo:cuer3 hadaMulti //if n elifs
            | ELFO ABRECUENTO operando:oper4 CIERRACUENTO cuerpo:cuer4 hadaMulti duendeStm
            | error CIERRAREGALO
            ; //if n elifs y else

//elif
hadaStm ::= HADA ABRECUENTO operando:oper CIERRACUENTO cuerpo ;

//n elifs
hadaMulti ::= hadaStm
            | hadaMulti hadaStm;

//else
duendeStm ::= DUENDE cuerpo;

estructura ::= forStmt 
                | doUntilStmt 
                | elfoStm;


//Funciones 

//Llamada de funciones
//hola()
//adios(intx, in)|
//error al poner funcion al final de una expresioncon final de linea ocupa doble final de linea para funcionar
ids ::= operando
    | ids MUERDAGO operando;
    
llamadaNavidenia ::= PERSONA:per ABRECUENTO CIERRACUENTO
                  |  PERSONA:per  ABRECUENTO ids CIERRACUENTO
                  ;

llamadaNavideniaAux ::= llamadaNavidenia FINREGALO;

// Producción del parámetro para la función
// tipo identificador
ayudanteDeSanta ::= t_santas:tst PERSONA:per
                {:
                // Meterlo a la tabla de símbolos
                listaTablaSimbolos.get(currentHash).add("tipo:param:" + per.toString()+":"+ tst.toString());
                :};

// Varios parámetros
ayudaDefFunNav ::= ayudanteDeSanta
                    | ayudaDefFunNav MUERDAGO ayudanteDeSanta;



// Ayuda para la definición de funciones
// function int func3
ayudaDefinirFuncionNavi ::= EMPEZONAVIDAD t_santas:tst PERSONA:per 
                    {:
                        currentHash = per.toString();
                        String tipoTabla = "main";
                        if (per.toString().equals("main")){
                            tipoTabla = "tipo:main:"+tst.toString();
                        }else{
                            tipoTabla = "tipo:function:"+tst.toString();
                            ArrayList<String> funcionMain = new ArrayList<String>();
                            funcionMain.add(tipoTabla);
                            listaTablaSimbolos.put(currentHash, funcionMain);
                        }

                        // Se verifica si el valor de retorno es apropiado
                        if((tst.equals("int") || tst.equals("float") || tst.equals("char") || tst.equals("bool"))){
                            RESULT = "dir:"+ tst;
                        }else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                             ", columna " + (cur_token.right) +": "  + "Este tipo de función no es permitido: "+ tst);
                             RESULT = "dir:null";
                        }
                    :}
                    ;

// Producción del cuerpo principal de la declaración de la función con parámetros y sin parámetros
// function int func3( )
// function int func3(int 1)
definirFunNav ::=  ayudaDefinirFuncionNavi:defin ABRECUENTO CIERRACUENTO 
                {:
                String[] partesOperando = defin.toString().split(":");
                RESULT = "dir:"+partesOperando[1];
                :}
                | ayudaDefinirFuncionNavi:defin ABRECUENTO ayudaDefFunNav CIERRACUENTO 
                {:
                String[] partesOperando = defin.toString().split(":");
                RESULT = "dir:"+partesOperando[1];
                :}
                | error FINREGALO 
                | error CIERRAREGALO
                | error ABREREGALO
                ;

// Definición completa de la función
bolsanavidenia ::= definirFunNav:defin
                {:
                 String[] partesOperando1 = defin.toString().split(":");
                 RESULT = "dir:" + partesOperando1[1];
                :}
                | definirFunNav:defin cuerpo:cuer               
                {:
                String[] partesOperando1 = defin.toString().split(":");
                String[] partesOperando2 = cuer.toString().split(":");
                if(!(partesOperando1[1].equals(partesOperando2[1]))){
                    System.out.println("Error Semántico: El retorno de la función no cumple con su tipo esperado de salida");
                    RESULT = "dir:" + partesOperando1[1];
                }
                :}
                ;

// Producción del return 
//Return (Return operando;)
envia ::= ENVIA operando:oper FINREGALO
        {:
            String[] partesOperando = oper.toString().split(":");
                    // Se verifica si tipo de la variable
                        if((partesOperando[1].equals("null") || partesOperando[1].equals("string"))){
                           System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                ", columna " + (cur_token.right) +": "  + "Tipo de retorno de la función es nulo, revise si esa variable existe");
                                RESULT = "dir:null"; 
                        }else{ 
                            RESULT = "dir:"+ partesOperando[1];
                            //System.out.println("El tipo de retorno es: " + partesOperando[1]);
                         }
        :}
        ;

// Producción del break
//Break (Break;)
corta ::= CORTA FINREGALO;

// Producción del print
// print: print(operando);
// Sólo puede imprimir literales y operandos de tipo int, float y string
narraNavidad ::= NARRA ABRECUENTO operando:opernarra CIERRACUENTO FINREGALO
                 {:
                String[] partesOperando = opernarra.toString().split(":");
                    if(partesOperando[1].equals("int")||partesOperando[1].equals("float") || partesOperando[1].equals("string")){
                        RESULT = "dir:"+ partesOperando[1];
                        System.out.println("tipo del read correcto");
                    }else{
                        RESULT = "dir:null";
                        System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                ", columna " + (cur_token.right) +": "  + "Tipo del print erróneo, revise su tipo");
                                RESULT = "dir:null"; 
                    }
                :}
               ;
                

// Producción del read
// read(operando)|
// Sólo puede leer operandos y literales de tipo int y float
escuchaNavidad ::= ESCUCHA ABRECUENTO operando:operescucha CIERRACUENTO FINREGALO
                {:
                String[] partesOperando = operescucha.toString().split(":");
                    if(partesOperando[1].equals("int")||(partesOperando[1].equals("float"))){
                        RESULT = "dir:"+ partesOperando[1];
                        System.out.println("tipo del read correcto");
                    }else{
                        RESULT = "dir:null";
                        System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                ", columna " + (cur_token.right) +": "  + "Tipo del read erróneo");
                                RESULT = "dir:null"; 
                    }
                :}
                ;


//Encapsula todas las expresiones para que se puedan colocar dentro de las funciones
poloNorte  ::=  decl_G 
                | creaRegalo
                | creaRegaloAssign
                | narraNavidad:narra
                {:
                    String[] partesOperando = narra.toString().split(":");
                    if(!(partesOperando[1].equals("null"))){
                        RESULT = "dir:"+ partesOperando[1];
                    }else{
                        RESULT = "dir:null";
                    }
                :}
                | estructura
                | envia:env
                {:
                    String[] partesOperando = env.toString().split(":");
                    if(!(partesOperando[1].equals("null"))){
                        RESULT = "dir:"+ partesOperando[1];
                    }else{
                        RESULT = "dir:null";
                    }
                :}
                | exprUni:prUni
                {:
                    String[] partesOperando = prUni.toString().split(":");
                    if(!(partesOperando[1].equals("null"))){
                        RESULT = "dir:"+ partesOperando[1];
                    }else{
                        RESULT = "dir:null";
                    }
                :}
                | escuchaNavidad:escucha
                {:
                    String[] partesOperando = escucha.toString().split(":");
                    if(!(partesOperando[1].equals("null"))){
                        RESULT = "dir:"+ partesOperando[1];
                    }else{
                        RESULT = "dir:null";
                    }
                :}
                | arrayInitialization:arz
                {:
                    if (arz != null) {
                        RESULT = arz;
                    } else {
                        RESULT = "dir:null";
                    }
                :}
                | arrayDeclaration:ard
                {:
                    if (ard != null) {
                        RESULT = ard;
                    } else {
                        RESULT = "dir:null";
                    }
                :}
                | corta
                | llamadaNavideniaAux
                ;

// Varias expresiones
regalo ::= poloNorte:poli1 
            {:
                if (poli1 != null) {
                    RESULT = poli1;
                } else {
                    RESULT = "dir:null";
                }
            :}    
            | regalo:reg poloNorte:poli2
            {:
                RESULT = poli2;
            :} 
            | error FINREGALO
            ;

// Varias funciones juntas
pbolsanavideniaAux ::=  bolsanavidenia
                    | pbolsanavideniaAux bolsanavidenia;


// Símbolo inicial con el que empieza la gramática
navidad ::= {:
                System.out.println("Empieza el asunto");
                :} 
                pbolsanavideniaAux
                {:
                imprimirTablaSimbolos();
                System.out.println("Termina el asunto");
                :};

antartica ::= bolsanavidenia | poloNorte;

regaloExtn ::= antartica
            | regaloExtn antartica;