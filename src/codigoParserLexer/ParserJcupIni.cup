package ParserLexer;
import java_cup.runtime.*;

// Tabla de símbolos
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;

action code {:

    // Definición del HashMap
    HashMap<String, ArrayList<String>> listaTablaSimbolos = new HashMap<String, ArrayList<String>>();
    String currentHash;
     
    // Función para imprimir la tabla de símbolos
    public void imprimirTablaSimbolos(){
        for (String key: listaTablaSimbolos.keySet()){
            System.out.println("Tabla de simbolo: " + key);
            System.out.println("La tabla contiene estos valores: ");
            for(String item: listaTablaSimbolos.get(key)){
                System.out.println(item);
            }
            System.out.println("");
        }
    }

    // Agarra el tipo del token en la tabla de símbolos
    public String getTipo(ArrayList<String> tablasSimbolos, String id){
        String tipo = "null";
        for(String token : tablasSimbolos){
            String[] partesToken = token.split(":");
            if(id.equals(partesToken[2])){
                System.out.println("Nombre variable:" + partesToken[2]  + " tipo: " + tipo);
                tipo = partesToken[3];
                
            }
        }
        return tipo;
    }
:}

parser code {:
    //Conectar parser a un escaner
    LexerJflex lex;

    @SuppressWarnings(value = { "deprecation" })
    public parser(LexerJflex lex){
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }

    //Manejo de errores
    public void syntax_error(Symbol cur_token) {
    System.err.println("Error sintáctico en la línea " + (cur_token.left+1) + 
                       ", columna " + (cur_token.right));
    }
    
    //Errores no recuperables
    public void unrecovered_syntax_error(Symbol cur_token) {
        if (cur_token.sym == sym.EOF) {
            System.err.println("Se alcanzó el final del archivo.");
        } else {
            System.err.println("Error de sintaxis irrecuperable en la línea " + (cur_token.left + 1) + 
                            ", columna " + (cur_token.right + 1));
        }
    }
:}

init with {: :};
scan with {: return lex.next_token(); :};

/* Lexer navideño */
terminal            EMPEZONAVIDAD, FESTIVAL, FIESTA, PERSONA, l_SANTA , l_SANTA_CLAUS, l_PAPANOEL, l_PASCUERO, l_COLACHO, ENTREGA, ELFO1, ELFO2, ELFO3, ELFO4, ELFO5, ELFO6;
terminal            GRINCH, QUIEN, RODOLFO, COMETA, BAILARIN, CUPIDO, DONNER, DASHER, ELFO, HADA, DUENDE, ENVUELVE, ENVOLTURA, HACE, REVISA, ENVIA, CORTA, MELCHOR, GASPAR, BALTASAR, POLO;
terminal            ABRECUENTO, CIERRACUENTO, ABREEMPAQUE, CIERRAEMPAQUE, ABREREGALO, CIERRAREGALO, FINREGALO, SANTACLAUS, PAPANOEL, SANNICOLAS, SINTERKLASS, VIEJITOPASCUERO, COLACHO;
terminal            ENTREGAREGALOS, MUERDAGO, NARRA, ESCUCHA, SANTACLAUSULA;

/* No terminales */
non terminal            poloNorte, NAVIDAD,t_santas, literales_navidenios, bolsanavidenia, pbolsanavideniaAux, narraNavidad, escuchaNavidad, entregaRegalos;
non terminal            grinchYQuien, unidadNavidenia, logisticadeNavidad, reyesMagos, regalo, cuerpo, ayudanteDeSanta, ayudaDefFunNav, definirFunNav, corta;
non terminal            elfos, creaRegalo, estructura, exprUni, exprP, regaloprin, exprRelLog, exprRelAux, exprLogAux, operando, operandoRel, operandoLog;
non terminal            opciones, creaRegaloAssign, whileStmt, forStmt, cuerpoMain, regaloExtn, antartica, doWhileStmt, envia, elfoStm, hadaStm, duendeStm, renos;
non terminal            decl_G, ayudaDefinirFuncionNavi, llamadaNavidenia, llamadaNavideniaAux, ids, accesoArray, arrayDeclaration, arrayInitialization, listaExpresiones;

//Precedence
precedence left RODOLFO, COMETA;
precedence left BAILARIN, CUPIDO;
precedence left DONNER, DASHER;
precedence left QUIEN, GRINCH;

precedence left ELFO1,
                ELFO2,
                ELFO3,
                ELFO4,
                ELFO5,
                ELFO6;

precedence left MELCHOR;
precedence left GASPAR;
precedence left BALTASAR;

/* Inicio */
start with NAVIDAD;

//Grupos de literales
literales_navidenios ::= l_SANTA:lst {:RESULT = lst + ":int";:} 
                    | l_SANTA_CLAUS:lst {:RESULT = lst + ":bool";:} 
                    | l_PAPANOEL:lst {:RESULT = lst + ":string";:} 
                    | l_PASCUERO:lst {:RESULT = lst + ":float";:} 
                    | l_COLACHO:lst {:RESULT = lst + ":char";:};

//print: print(operando);
narraNavidad ::= NARRA ABRECUENTO operando CIERRACUENTO FINREGALO;

//read:  read(operando);
escuchaNavidad ::= ESCUCHA ABRECUENTO operando CIERRACUENTO FINREGALO;

//Tipos
t_santas ::= SANTACLAUS:tst {:RESULT = tst;:}       //string,
            | PAPANOEL:tst {:RESULT = tst;:}        //int
            | SANNICOLAS:tst {:RESULT = tst;:}      //float
            | SINTERKLASS:tst {:RESULT = tst;:}     //double
            | VIEJITOPASCUERO:tst {:RESULT = tst;:} //void
            | COLACHO:tst {:RESULT = tst;:}         //char
            | SANTACLAUSULA:tst {:RESULT = tst;:};  //bool


//Return (Return operando;)
envia ::= ENVIA operando:oper FINREGALO
        {:
            String[] partesOperando = oper.toString().split(":");
                    // Se verifica si tipo de la variable
                        if(!(partesOperando[1].equals("null"))){
                            RESULT = "dir:"+ partesOperando[1];
                            System.out.println("El tipo de retorno es: " + partesOperando[1]);
                        }else{
                                System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                ", columna " + (cur_token.right) +": "  + "Tipo de retorno de la función es nulo, revise si esa variable existe");
                                RESULT = "dir:null";
                         }
        :}
        ;

//Break (Break;)
corta ::= CORTA FINREGALO;

// Operadores de comparación
elfos ::= ELFO1:elfg // ==
        | ELFO2:elfg // !=
        | ELFO3:elfn // >
        | ELFO4:elfn // <
        | ELFO5:elfn // =>
        | ELFO6:elfn // =<
        ;

// Operadores aritméticos
renos ::= COMETA:rn    {:RESULT = rn;:} // -
         | RODOLFO:rn  {:RESULT = rn;:} // +
         | BAILARIN:rn {:RESULT = rn;:} // *
         | CUPIDO:rn   {:RESULT = rn;:} // /
         | DONNER:rn   {:RESULT = rn;:} // ~
         | DASHER:rn   {:RESULT = rn;:} // **
         ;

// Operaciones aritméticas
exprUni ::= exprP FINREGALO;

exprP ::= regaloprin | exprRelLog;

regaloprin ::= COMETA operando
            | operando:oper1 renos:rn operando:oper2            
            /**{:
                if(oper1.equals(oper2)){
                    System.out.println("Los operandos de esta operación son" +rn+ " del mismo tipo");
                }else{
                    System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                        ", columna " + (cur_token.right) +":"  + "Los tipos de los operando no son iguales: " + oper1 + oper2);
                        RESULT = "dir:null";
                }
            :}*/
            ;

//Operadores unarios
unidadNavidenia ::= GRINCH | QUIEN;

grinchYQuien ::= unidadNavidenia operando;

//Expreisones relacionales
exprRelAux ::= operando elfos operando;

exprRelLog ::= exprRelAux | exprLogAux;

//Operadores logicos      # | ^
logisticadeNavidad ::= MELCHOR | GASPAR;

// ! operando | operando # | ^ operando
exprLogAux ::= BALTASAR operando 
            | operando logisticadeNavidad operando;

// Lo que sea que se vaya a operar más carga del tipo per y literal 
operando ::= PERSONA:per
        {:
            ArrayList<String> ts = listaTablaSimbolos.get(currentHash);
            String tipoId = getTipo(ts,per.toString());
            if(tipoId != "null"){
                RESULT = "dir:"+tipoId;
                System.out.println("Acá entró y funcionó subir el tipo del per: " + tipoId);
            }else{
                RESULT = "dir:null";
                System.out.println("per tiene dirección nula:" + per);
            }
        :}
        | literales_navidenios:lst 
        {:
            String[] partesOperando = lst.toString().split(":");
            if(partesOperando[1] != "null"){
                RESULT = "dir:"+partesOperando[1]; 
                System.out.println("Acá entró y funcionó subir el tipo del literal: " + lst); 
            }else{
                RESULT = "dir:null";
            }
       :}
        | llamadaNavidenia 
        | accesoArray 
        | exprP 
        | grinchYQuien 
        | ABRECUENTO operando:ope CIERRACUENTO
        ;

//Declaracion de variable sin asignación
creaRegalo ::= POLO t_santas:tst PERSONA:per FINREGALO
                {:
                    listaTablaSimbolos.get(currentHash).add("tipo:Local:" + per.toString()+":"+ tst.toString());
                        if(!(tst.equals("null"))){
                            System.out.println("Declarada la variable sin asignación bien");
                            RESULT = "dir:"+ tst;
                        }else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                            ", columna " + (cur_token.right) + " Declaración sin variable." );
                            RESULT = "dir:null";
                        }
                :}
                ;

// Declaración con asignación
creaRegaloAssign ::= POLO t_santas:tst PERSONA:per ENTREGA operando:oper1 FINREGALO
                {:
                    listaTablaSimbolos.get(currentHash).add("tipo:Local:" + per.toString()+":"+ tst.toString());
                    String[] partesOperando = oper1.toString().split(":");

                    // Se verifica si tipo de la variable
                        if(!(tst.equals("null"))){
                            System.out.println("tipo de la variable permitido");
                            if(tst.equals(partesOperando[1])){
                                System.out.println("La variable coincide con su asignación");
                                RESULT = "dir:"+ tst;
                            }
                            else{
                                System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                ", columna " + (cur_token.right) +": "  + "Tipo de la variable no coincide con su tipo de asignación");
                                RESULT = "dir:null";
                            }
                        }else{
                            System.err.println("Error semántico en la línea " + (cur_token.left) + 
                            ", columna " + (cur_token.right) +": "  + "Tipo de la variable vacía");
                            RESULT = "dir:null";
                        }
                :}

                | error FINREGALO
                ;
                
//Redeclaración de variables
decl_G ::= PERSONA ENTREGA operando FINREGALO;

cuerpo ::= ABREREGALO regalo CIERRAREGALO;


//arrays
//local int arr[3]|
arrayDeclaration ::= POLO t_santas:tst PERSONA ABREEMPAQUE operando CIERRAEMPAQUE FINREGALO
                    | error FINREGALO
                    ;

// Regla de inicialización de arrays
//int arr[3] <= {a,b,3}|
arrayInitialization ::= t_santas:tst 
                        /*{: 
                        String[] partesOperando = tst.toString().split(":"); 
                        if(tst.equals("int")){
                            System.out.println("tipo de iniciación de array permitido");
                        }else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                             ", columna " + (cur_token.right) +":"  + "Tipo de iniciacióm de array no permitido:");
                        }
                        :}*/
                    PERSONA ABREEMPAQUE operando CIERRAEMPAQUE ENTREGA ABREREGALO listaExpresiones CIERRAREGALO FINREGALO 
                    | error FINREGALO
                    ;


listaExpresiones ::= operando
                 | listaExpresiones MUERDAGO operando;

//Acceso y asignacion array
//arr[1] ó  arr[3] <= 4|
accesoArray ::= PERSONA:per ABREEMPAQUE operando CIERRAEMPAQUE
            | PERSONA:per ABREEMPAQUE operando CIERRAEMPAQUE ENTREGA operando FINREGALO
            ;

//Ciclos

//While
//while ( i <_ 5 ){}
whileStmt ::= ENVOLTURA ABRECUENTO operando CIERRACUENTO cuerpo;

//do until (do while)
//do{ cuerpo }until ( i <_ 5 )|
doWhileStmt ::= HACE cuerpo REVISA ABRECUENTO operando CIERRACUENTO FINREGALO;

//For 
//for(x=2,x<20,++x)
forStmt ::= ENVUELVE ABRECUENTO PERSONA ENTREGA l_SANTA:lst  MUERDAGO exprRelLog MUERDAGO grinchYQuien CIERRACUENTO cuerpo
            | ENVUELVE ABRECUENTO PAPANOEL PERSONA ENTREGA l_SANTA MUERDAGO exprRelLog MUERDAGO grinchYQuien CIERRACUENTO cuerpo
            | ENVUELVE ABRECUENTO POLO PAPANOEL PERSONA ENTREGA operando MUERDAGO exprRelLog MUERDAGO grinchYQuien CIERRACUENTO cuerpo;

//if - elif - else
//if
elfoStm::= ELFO ABRECUENTO operando CIERRACUENTO cuerpo;

//elif
hadaStm::= HADA ABRECUENTO operando CIERRACUENTO cuerpo;

//else
duendeStm ::= DUENDE cuerpo;

estructura ::= whileStmt 
                | forStmt 
                | doWhileStmt 
                | elfoStm 
                | hadaStm 
                | duendeStm
                ;

//Funciones 

//Llamada de funciones
//hola()
//adios(intx, in)|
//error al poner funcion al final de una expresioncon final de linea ocupa doble final de linea para funcionar
ids ::= operando
    | ids MUERDAGO operando;
    
llamadaNavidenia ::= PERSONA:per ABRECUENTO CIERRACUENTO
                  |  PERSONA:per  ABRECUENTO ids CIERRACUENTO
                  ;

llamadaNavideniaAux ::= llamadaNavidenia FINREGALO;

// Parámetro: tipo identificador
ayudanteDeSanta ::= t_santas:tst PERSONA:per
                {:
                // Meterlo a la tabla de símbolos
                listaTablaSimbolos.get(currentHash).add("tipo:param:" + per.toString()+":"+ tst.toString());
                :};

// Varios parámetros
ayudaDefFunNav ::= ayudanteDeSanta
                    | ayudaDefFunNav MUERDAGO ayudanteDeSanta;



// Ayuda para la definición de funciones
ayudaDefinirFuncionNavi ::= EMPEZONAVIDAD t_santas:tst PERSONA:per
                        {:
                        currentHash = per.toString();
                        String tipoTabla = "main";
                        if (per.toString().equals("main")){
                            tipoTabla = "tipo:main:"+tst.toString();
                        }else{
                            tipoTabla = "tipo:function:"+tst.toString();
                            ArrayList<String> funcionMain = new ArrayList<String>();
                            funcionMain.add(tipoTabla);
                            listaTablaSimbolos.put(currentHash, funcionMain);
                        }

                        // Se verifica si el valor de retorno es apropiado
                        if((tst.equals("int") || tst.equals("float") || tst.equals("char") || tst.equals("bool"))){
                            System.out.println("tipo de la función permitida");
                            RESULT = "dir:"+ tst;
                        }else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                             ", columna " + (cur_token.right) +": "  + "Tipo de la función no permitida");
                        }
                        :}
                        ;

//Definición de funciones
definirFunNav ::=  ayudaDefinirFuncionNavi ABRECUENTO CIERRACUENTO 
                | ayudaDefinirFuncionNavi ABRECUENTO ayudaDefFunNav CIERRACUENTO 
                | error FINREGALO 
                | error CIERRAREGALO
                | error ABREREGALO
                ;

bolsanavidenia ::= definirFunNav
                | definirFunNav cuerpo;

pbolsanavideniaAux ::=  bolsanavidenia
                    | pbolsanavideniaAux bolsanavidenia;

NAVIDAD ::= {:
                System.out.println("Empieza el asunto");
                :} 
                pbolsanavideniaAux
                {:
                imprimirTablaSimbolos();
                System.out.println("Termina el asunto");
                :};


//funcion main
/*cuerpoMain ::= ABREREGALO regaloExtn CIERRAREGALO;

entregaRegalos ::= {:
                    System.out.println("Empieza el asunto");
                    :} 
                    EMPEZONAVIDAD VIEJITOPASCUERO ENTREGAREGALOS ABRECUENTO CIERRACUENTO cuerpoMain 
                    {:
                    imprimirTablaSimbolos();
                    System.out.println("Termina el asunto");
                    :};
*/

//Encapsula todas las expresiones para que se puedan colocar dentro de las funciones
poloNorte  ::=  decl_G 
                | creaRegalo
                | creaRegaloAssign
                | narraNavidad 
                | estructura
                | envia 
                | exprUni
                | escuchaNavidad
                | corta
                | llamadaNavideniaAux;

//Produccion de expresiones
regalo ::= poloNorte
            | regalo poloNorte;

antartica ::= bolsanavidenia | poloNorte;

regaloExtn ::= antartica
            | regaloExtn antartica;