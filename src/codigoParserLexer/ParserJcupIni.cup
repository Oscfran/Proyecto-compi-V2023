package ParserLexer;
import java_cup.runtime.*;

// Tabla de símbolos
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;

action code {:

    // Definición del HashMap
    HashMap<String, ArrayList<String>> listaTablaSimbolos = new HashMap<String, ArrayList<String>>();
    String currentHash;
     
    // Función para imprimir la tabla de símbolos
    public void imprimirTablaSimbolos(){
        for (String key: listaTablaSimbolos.keySet()){  
            System.out.println("\nLa tabla contiene estos valores: ");
            System.out.println("Tabla de simbolo: " + key);
            for(String item: listaTablaSimbolos.get(key)){
                System.out.println(item);
            }
            System.out.println("");
        }
    }

    // Agarra el tipo del token en la tabla de símbolos
    public String getTipo(ArrayList<String> tablasSimbolos, String id){
        String tipo = "null";
        for(String token : tablasSimbolos){
            String[] partesToken = token.split(":");
            if(id.equals(partesToken[2])){
                //System.out.println("Nombre variable:" + partesToken[2]  + " tipo: " + tipo);
                tipo = partesToken[3];
                
            }
        }
        return tipo;
    }
:}

parser code {:
    //Conectar parser a un escaner
    LexerJflex lex;

    @SuppressWarnings(value = { "deprecation" })
    public parser(LexerJflex lex){
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }

    //Manejo de errores
    public void syntax_error(Symbol cur_token) {
    System.err.println("Error sintáctico en la línea " + (cur_token.left+1) + 
                       ", columna " + (cur_token.right));
    }
    
    //Errores no recuperables
    public void unrecovered_syntax_error(Symbol cur_token) {
        if (cur_token.sym == sym.EOF) {
            System.err.println("Se alcanzó el final del archivo.");
        } else {
            System.err.println("Error de sintaxis irrecuperable en la línea " + (cur_token.left + 1) + 
                            ", columna " + (cur_token.right + 1));
        }
    }
:}

init with {: :};
scan with {: return lex.next_token(); :};

/* Lexer navideño */
terminal            EMPEZONAVIDAD, FESTIVAL, FIESTA, PERSONA, l_SANTA , l_SANTA_CLAUS, l_PAPANOEL, l_PASCUERO, l_COLACHO, ENTREGA, ELFO1, ELFO2, ELFO3, ELFO4, ELFO5, ELFO6;
terminal            GRINCH, QUIEN, RODOLFO, COMETA, BAILARIN, CUPIDO, DONNER, DASHER, ELFO, HADA, DUENDE, ENVUELVE, ENVOLTURA, HACE, REVISA, ENVIA, CORTA, MELCHOR, GASPAR, BALTASAR, POLO;
terminal            ABRECUENTO, CIERRACUENTO, ABREEMPAQUE, CIERRAEMPAQUE, ABREREGALO, CIERRAREGALO, FINREGALO, SANTACLAUS, PAPANOEL, SANNICOLAS, SINTERKLASS, VIEJITOPASCUERO, COLACHO;
terminal            ENTREGAREGALOS, MUERDAGO, NARRA, ESCUCHA, SANTACLAUSULA, CUPIENTERO;

/* No terminales */
non terminal            poloNorte, navidad,t_santas, literales_navidenios, bolsanavidenia, pbolsanavideniaAux, narraNavidad, escuchaNavidad, entregaRegalos;
non terminal            grinchYQuien, unidadNavidenia, logisticadeNavidad, reyesMagos, regalo, cuerpo, ayudanteDeSanta, ayudaDefFunNav, definirFunNav, corta;
non terminal            elfos, creaRegalo, estructura, exprUni, exprP, regaloprin, exprRelLog, exprRelAux, exprLogAux, operando, operandoRel, operandoLog;
non terminal            opciones,creaRegaloAssign, whileStmt, forStmt, cuerpoMain, regaloExtn, antartica, doWhileStmt, envia, elfoStm, hadaStm, hadaMulti, duendeStm, renos;
non terminal            decl_G, ayudaDefinirFuncionNavi, llamadaNavidenia, llamadaNavideniaAux, ids, accesoArray, arrayDeclaration, arrayInitialization, listaExpresiones;

//Precedence
precedence left RODOLFO, COMETA;
precedence left BAILARIN, CUPIDO;
precedence left DONNER, DASHER;
precedence left QUIEN, GRINCH;

precedence left ELFO1,
                ELFO2,
                ELFO3,
                ELFO4,
                ELFO5,
                ELFO6;

precedence left MELCHOR;
precedence left GASPAR;
precedence left BALTASAR;

/* Inicio */
start with navidad;

//Grupos de literales
literales_navidenios ::= l_SANTA:lst {:RESULT = lst + ":int";:} 
                    | l_SANTA_CLAUS:lst {:RESULT = lst + ":bool";:} 
                    | l_PAPANOEL:lst {:RESULT = lst + ":string";:} 
                    | l_PASCUERO:lst {:RESULT = lst + ":float";:} 
                    | l_COLACHO:lst {:RESULT = lst + ":char";:};

//print: print(operando);
narraNavidad ::= NARRA ABRECUENTO operando:oper CIERRACUENTO FINREGALO
               ;
                

//read:  read(operando)|
escuchaNavidad ::= ESCUCHA ABRECUENTO operando:operescucha CIERRACUENTO FINREGALO
                {:
                String[] partesOperando = operescucha.toString().split(":");
                    if(partesOperando[1].equals("int")||(partesOperando[1].equals("float"))){
                        RESULT = "dir:"+ partesOperando[1];
                        System.out.println("tipo del read correcto");
                    }else{
                        RESULT = "dir:null";
                        System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                ", columna " + (cur_token.right) +": "  + "Tipo del read erróneo");
                                RESULT = "dir:null"; 
                    }
                :};

//Tipos
t_santas ::= SANTACLAUS:tst {:RESULT = tst;:}       //string,
            | PAPANOEL:tst {:RESULT = tst;:}        //int
            | SANNICOLAS:tst {:RESULT = tst;:}      //float
            | SINTERKLASS:tst {:RESULT = tst;:}     //double
            | VIEJITOPASCUERO:tst {:RESULT = tst;:} //void
            | COLACHO:tst {:RESULT = tst;:}         //char
            | SANTACLAUSULA:tst {:RESULT = tst;:};  //bool


//Return (Return operando;)
envia ::= ENVIA operando:oper FINREGALO
        {:
            String[] partesOperando = oper.toString().split(":");
                    // Se verifica si tipo de la variable
                        if((partesOperando[1].equals("null") || partesOperando[1].equals("string"))){
                           System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                ", columna " + (cur_token.right) +": "  + "Tipo de retorno de la función es nulo, revise si esa variable existe");
                                RESULT = "dir:null"; 
                        }else{ 
                            RESULT = "dir:"+ partesOperando[1];
                            //System.out.println("El tipo de retorno es: " + partesOperando[1]);
                         }
        :}
        ;

//Break (Break;)
corta ::= CORTA FINREGALO;

// Operadores de comparación
elfos ::= ELFO1:elf {:RESULT = elf;:}// ==
        | ELFO2:elf {:RESULT = elf;:}// !=
        | ELFO3:elf {:RESULT = elf;:}// >
        | ELFO4:elf {:RESULT = elf;:}// <
        | ELFO5:elf {:RESULT = elf;:}// =>
        | ELFO6:elf {:RESULT = elf;:}// =<
        ;

// Operadores aritméticos
renos ::= COMETA:rn    {:RESULT = rn;:} // -
         //| CUPIENTERO:rn {:RESULT = rn;:} // ?
         | RODOLFO:rn  {:RESULT = rn;:} // +
         | BAILARIN:rn {:RESULT = rn;:} // *
         | CUPIDO:rn   {:RESULT = rn;:} // /
         | DONNER:rn   {:RESULT = rn;:} // ~
         | DASHER:rn   {:RESULT = rn;:} // **
         ;

//Encapsula todas las expresiones para que se puedan colocar dentro de las funciones
poloNorte  ::=  decl_G 
                | creaRegalo
                | creaRegaloAssign
                | narraNavidad 
                | estructura
                | envia:env
                {:
                    String[] partesOperando = env.toString().split(":");
                    if(!(partesOperando[1].equals("null"))){
                        RESULT = "dir:"+ partesOperando[1];
                    }else{
                        RESULT = "dir:null";
                    }
                :}
                | exprUni:prUni
                {:
                    String[] partesOperando = prUni.toString().split(":");
                    if(!(partesOperando[1].equals("null"))){
                        RESULT = "dir:"+ partesOperando[1];
                    }else{
                        RESULT = "dir:null";
                    }
                :}

                | escuchaNavidad:escucha
                {:
                    String[] partesOperando = escucha.toString().split(":");
                    if(!(partesOperando[1].equals("null"))){
                        RESULT = "dir:"+ partesOperando[1];
                    }else{
                        RESULT = "dir:null";
                    }
                :}
                | corta
                | llamadaNavideniaAux;

// Permite expresiones sin declaración (siempre dentro de la función)
exprUni ::= exprP:pr FINREGALO
            {:
            String[] partesOperando = pr.toString().split(":");
                if(!(partesOperando[1].equals("null"))){
                    RESULT = "dir:"+ partesOperando[1];
                }
                else{
                    RESULT = "dir:null";
                } 
            :};

exprP ::= regaloprin:prin
        {:
            String[] partesOperando = prin.toString().split(":");
            if(!(partesOperando[1].equals("null"))){
                RESULT = "dir:"+ partesOperando[1];
            }else{
                RESULT = "dir:null";
            }
        :} 
        | exprRelLog:prlog
        {:  
            //System.out.println("prlog es: "+prlog);
            String[] partesOperando = prlog.toString().split(":");
            if(prlog != null || !(partesOperando[1].equals("null"))){
                RESULT = "dir:"+partesOperando[1];
            }
            else{
                RESULT = "dir:null";
            }
        :} 
        ;

// Operación aritmética
regaloprin ::= COMETA operando:oper3 
            {:
                String[] partesOperando = oper3.toString().split(":");
                if(partesOperando[1].equals("int") || partesOperando[1].equals("float") ){
                    RESULT = "dir:"+partesOperando[1];  
                }else{
                    RESULT = "dir:null";
                }
            :}
            | operando:oper1 renos:rn operando:oper2        
            {:
                String[] partesOperando1 = oper1.toString().split(":");
                String[] partesOperando2 = oper2.toString().split(":");

                if(rn.equals("/")){
                    if(partesOperando1[1].equals(partesOperando2[1])){
                        if(partesOperando1[1].equals("float")){
                            System.out.println("Es división flotante");
                            RESULT = "dir:"+partesOperando1[1];
                        }
                        else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) +
                                ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos no son del tipo permitido: " + partesOperando1[1] + ", " + partesOperando2[1]);
                            RESULT = "dir:null";
                        }
                    }
                    else{
                        System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                            ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos no son iguales: " + partesOperando1[1] + ", " + partesOperando2[1]);
                        RESULT = "dir:null";
                    }
                }   
                else if(rn.equals("?")){
                    if(partesOperando1[1].equals(partesOperando2[1])){
                        if(partesOperando1[1].equals("int")){
                            System.out.println("Es división entera");
                            RESULT = "dir:"+partesOperando1[1];
                        }
                        else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                                ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos no son del tipo permitido: " + partesOperando1[1] + ", " + partesOperando2[1]);
                            RESULT = "dir:null";
                        }
                    }
                    else{
                        System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                            ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos no son iguales: " + partesOperando1[1] + ", " + partesOperando2[1]);
                        RESULT = "dir:null";
                    }
                }
                else{  
                    if(partesOperando1[1].equals(partesOperando2[1])){
                        if(partesOperando1[1].equals("int") || partesOperando1[1].equals("float")){
                                RESULT = "dir:"+partesOperando1[1];
                        }
                        else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                            ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos no son del tipo permitidos \n\t\t\t\t\t para las operaciones aritméticas: " + partesOperando1[1] + ", " + partesOperando2[1]);
                            RESULT = "dir:null";
                        }
                    }
                    else{
                        System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                            ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos no son iguales: " + partesOperando1[1] + ", " + partesOperando2[1]);
                        RESULT = "dir:null";
                        }
                    }     
            :}            ;

//Operadores unarios ++, --
unidadNavidenia ::= GRINCH:gr {:RESULT = gr;:}
                 | QUIEN:qn {:RESULT = qn;:};

grinchYQuien ::= unidadNavidenia operando:oper1
            {:
            String[] partesOperando = oper1.toString().split(":");
            if(partesOperando[1] != "null"){
                RESULT = "dir:"+partesOperando[1];  
            }else{
                RESULT = "dir:null";
            }
            :}
            ;



//Expresiones relacionales
exprRelAux ::= operando:oper1 elfos:elf operando:oper2
            {:
            //System.out.println("Oper1 es:  "+ oper1);
            //System.out.println("Oper2 es:  "+ oper2);
            String[] partesOperando1 = oper1.toString().split(":");
            String[] partesOperando2 = oper2.toString().split(":");
                // Permite expresiones relacionales (==, !=) del mismo tipo, mientras que sean int, float y bool
                if((elf.equals("==") || elf.equals("!="))){
                    if (partesOperando1[1].equals(partesOperando2[1])){
                        System.out.println("Los tipos de los operadores == y != son los mismos");
                        if ((partesOperando1[1].equals("int")|| partesOperando1[1].equals("float")|| partesOperando1[1].equals("bool"))){
                            System.out.println("Los tipos int, float y bool son permitidos");
                            RESULT = "dir:"+partesOperando1[1];
                        }
                        else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                                ", columna " + (cur_token.right) +": "  + "Los tipos de los operando no son permitidos i-f-b: ");
                                 RESULT = "dir:null";
                        }
                    }
                    else{
                        System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                        ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos relacionales no son iguales: " + partesOperando1[1] + ", " + partesOperando2[1]);
                        RESULT = "dir:null";
                    }
                }
                // Permite expresiones relacionales (<, >, =>, =<) del mismo tipo, mientras que sean int y float
                else{
                    if (partesOperando1[1].equals(partesOperando2[1])){
                        System.out.println("Los tipos del resto de operadores relacionales son los mismos");
                        if (partesOperando1[1].equals("int") || partesOperando1[1].equals("float")){
                            System.out.println("Los tipos int, float son permitidos");
                            RESULT = "dir:"+partesOperando1[1];
                        }
                        else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                                ", columna " + (cur_token.right) +": "  + "Los tipos de los operando no son permitidos i-f: ");
                                 RESULT = "dir:null";
                        }
                    }
                    else{
                        System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                        ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos relacionales no son iguales: " + partesOperando1[1] + ", " + partesOperando2[1]);
                        RESULT = "dir:null";
                    }
                }
            :}
            ;

exprRelLog ::= exprRelAux:relaux 
            {:
            //System.out.println("relaux es:" +relaux);
            if(relaux != null){
                RESULT = relaux;
            }
            else{
                RESULT = "dir:null";
            }
            :}
            | exprLogAux:logaux
            {:
            //System.out.println("logaux es:" +logaux);
            if(logaux != null){
                RESULT = logaux;
            }
            else{
                RESULT = "dir:null";
            }
            :}
            ;



//Operadores logicos      # | ^
logisticadeNavidad ::= MELCHOR:mel {:RESULT = mel;:} 
                    | GASPAR:gal {:RESULT = gal;:};

// ! operando | operando # | ^ operando
exprLogAux ::= BALTASAR operando:oper1
            {:
            String[] partesOperando = oper1.toString().split(":");
            if(oper1 != null || !(partesOperando[1].equals("null"))){
                RESULT = "dir:"+partesOperando[1];
            }
            else{
                RESULT = "dir:null";
            }
            :}
            | operando:oper1 logisticadeNavidad:logis operando:oper2
            {:
            String[] partesOperando1 = oper1.toString().split(":");
            String[] partesOperando2 = oper2.toString().split(":");
                if(partesOperando1[1].equals(partesOperando2[1])){
                    /*System.out.println("Los operandos de esta operación en la línea" + (cur_token.left+1) + 
                     ", columna " + (cur_token.right) +":"+"son del mismo tipo logico");*/
                    RESULT = "dir:"+partesOperando1[1];
                }else{
                    System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                        ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos lógicos no son iguales: " + partesOperando1[1] + ", " + partesOperando2[1]);
                        RESULT = "dir:null";
                }
            :};


// Lo que sea que se vaya a operar más carga del tipo per y literal 
operando ::= PERSONA:per
        {:
            ArrayList<String> ts = listaTablaSimbolos.get(currentHash);
            String tipoId = getTipo(ts,per.toString());
            if(tipoId != "null"){
                RESULT = "dir:"+tipoId;
            }else{
                RESULT = "dir:null";
            }
        :}
        | literales_navidenios:lst 
        {:
            String[] partesOperando = lst.toString().split(":");
            if(partesOperando[1] != "null"){
                RESULT = "dir:"+partesOperando[1]; 
            }else{
                RESULT = "dir:null";
            }
       :}
        | llamadaNavidenia 
        | accesoArray 
        | exprP:pr 
        {:
            //System.out.println("pr es:" +pr);
            String[] partesOperando = pr.toString().split(":");
            if(partesOperando[1] != "null"){
                RESULT = "dir:"+partesOperando[1];  
            }else{
                RESULT = "dir:null";
            }
        :}
        | grinchYQuien:gq
        {:
            //System.out.println("pr es:" +pr);
            String[] partesOperando = gq.toString().split(":");
            if(partesOperando[1] != "null"){
                RESULT = "dir:"+partesOperando[1];  
            }else{
                RESULT = "dir:null";
            }
        :}
        | ABRECUENTO operando:ope CIERRACUENTO
        ;

//Declaracion de variable sin asignación
creaRegalo ::= POLO t_santas:tst PERSONA:per FINREGALO
                {:
                    listaTablaSimbolos.get(currentHash).add("tipo:Local:" + per.toString()+":"+ tst.toString());
                        if(!(tst.equals("null"))){
                            //System.out.println("Bien declarada la variable sin asignación");
                            RESULT = "dir:"+ tst;
                        }else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                            ", columna " + (cur_token.right) + " Mal declarada la variable sin asignación");
                            RESULT = "dir:null";
                        }
                :}
                ;

// Declaración con asignación
creaRegaloAssign ::= POLO t_santas:tst PERSONA:per ENTREGA operando:oper1 FINREGALO
                {:
                    listaTablaSimbolos.get(currentHash).add("tipo:Local:" + per.toString()+":"+ tst.toString());
                    String[] partesOperando = oper1.toString().split(":");

                    // Se verifica si tipo de la variable
                        if(!(tst.equals("null"))){
                            //System.out.println("tipo de la variable permitido");
                            if(tst.equals(partesOperando[1])){
                                //System.out.println("La variable coincide con su asignación");
                                RESULT = "dir:"+ tst;
                            }
                            else{
                                System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                ", columna " + (cur_token.right) +":"  + " Tipo de la variable no coincide con su tipo de asignación");
                                RESULT = "dir:null";
                            }
                        }else{
                            System.err.println("Error semántico en la línea " + (cur_token.left) + 
                            ", columna " + (cur_token.right) +":"  + "Tipo de la variable vacía");
                            RESULT = "dir:null";
                        }
                :}

                | error FINREGALO
                ;
                
//Redeclaración de variables
decl_G ::= PERSONA ENTREGA operando FINREGALO;

cuerpo ::= ABREREGALO CIERRAREGALO
        | ABREREGALO regalo:reg CIERRAREGALO
        {:
            String[] partesOperando = reg.toString().split(":");
            if(!(partesOperando[1].equals("null"))){
                RESULT = "dir:"+ partesOperando[1];
            }else{
                RESULT = "dir:null";
            }
        :}
        ;


//arrays
//local int arr[3]|
arrayDeclaration ::= POLO t_santas:tst PERSONA ABREEMPAQUE operando CIERRAEMPAQUE FINREGALO
                    | error FINREGALO
                    ;

// Regla de inicialización de arrays
//int arr[3] <= {a,b,3}|
arrayInitialization ::= t_santas:tst 
                        /*{: 
                        String[] partesOperando = tst.toString().split(":"); 
                        if(tst.equals("int")){
                            System.out.println("tipo de iniciación de array permitido");
                        }else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                             ", columna " + (cur_token.right) +":"  + "Tipo de iniciacióm de array no permitido:");
                        }
                        :}*/
                    PERSONA ABREEMPAQUE operando CIERRAEMPAQUE ENTREGA ABREREGALO listaExpresiones CIERRAREGALO FINREGALO 
                    | error FINREGALO
                    ;


listaExpresiones ::= operando
                 | listaExpresiones MUERDAGO operando;

//Acceso y asignacion array
//arr[1] ó  arr[3] <= 4|
accesoArray ::= PERSONA:per ABREEMPAQUE operando CIERRAEMPAQUE
            | PERSONA:per ABREEMPAQUE operando CIERRAEMPAQUE ENTREGA operando FINREGALO
            ;

//Ciclos

//While
//while ( i <_ 5 ){}
whileStmt ::= ENVOLTURA ABRECUENTO operando CIERRACUENTO cuerpo;

//do until (do while)
//do{ cuerpo }until ( i <_ 5 )|
doWhileStmt ::= HACE cuerpo REVISA ABRECUENTO operando CIERRACUENTO FINREGALO;

//For 
//for(x=2,x<20,++x)
forStmt ::= ENVUELVE ABRECUENTO PERSONA ENTREGA l_SANTA:lst  MUERDAGO exprRelLog MUERDAGO grinchYQuien CIERRACUENTO cuerpo
            | ENVUELVE ABRECUENTO PAPANOEL PERSONA ENTREGA l_SANTA MUERDAGO exprRelLog MUERDAGO grinchYQuien CIERRACUENTO cuerpo
            | ENVUELVE ABRECUENTO POLO PAPANOEL PERSONA ENTREGA operando MUERDAGO exprRelLog MUERDAGO grinchYQuien CIERRACUENTO cuerpo;

//if - elif - else
//if
elfoStm::= ELFO ABRECUENTO operando CIERRACUENTO cuerpo
            | ELFO ABRECUENTO operando CIERRACUENTO cuerpo duendeStm //if y else
            | ELFO ABRECUENTO operando CIERRACUENTO cuerpo hadaMulti //if n elifs
            | ELFO ABRECUENTO operando CIERRACUENTO cuerpo hadaMulti duendeStm; //if n elifs y else

//elif
hadaStm ::= HADA ABRECUENTO operando CIERRACUENTO cuerpo;

//n elifs
hadaMulti ::= hadaStm
            | hadaMulti hadaStm;

//else
duendeStm ::= DUENDE cuerpo;

estructura ::= whileStmt 
                | forStmt 
                | doWhileStmt 
                | elfoStm;


//Funciones 

//Llamada de funciones
//hola()
//adios(intx, in)|
//error al poner funcion al final de una expresioncon final de linea ocupa doble final de linea para funcionar
ids ::= operando
    | ids MUERDAGO operando;
    
llamadaNavidenia ::= PERSONA:per ABRECUENTO CIERRACUENTO
                  |  PERSONA:per  ABRECUENTO ids CIERRACUENTO
                  ;

llamadaNavideniaAux ::= llamadaNavidenia FINREGALO;

// Parámetro: tipo identificador
ayudanteDeSanta ::= t_santas:tst PERSONA:per
                {:
                // Meterlo a la tabla de símbolos
                listaTablaSimbolos.get(currentHash).add("tipo:param:" + per.toString()+":"+ tst.toString());
                :};

// Varios parámetros
ayudaDefFunNav ::= ayudanteDeSanta
                    | ayudaDefFunNav MUERDAGO ayudanteDeSanta;



// Ayuda para la definición de funciones
ayudaDefinirFuncionNavi ::= EMPEZONAVIDAD t_santas:tst PERSONA:per
                    {:
                        currentHash = per.toString();
                        String tipoTabla = "main";
                        if (per.toString().equals("main")){
                            tipoTabla = "tipo:main:"+tst.toString();
                        }else{
                            tipoTabla = "tipo:function:"+tst.toString();
                            ArrayList<String> funcionMain = new ArrayList<String>();
                            funcionMain.add(tipoTabla);
                            listaTablaSimbolos.put(currentHash, funcionMain);
                        }

                        // Se verifica si el valor de retorno es apropiado
                        if((tst.equals("int") || tst.equals("float") || tst.equals("char") || tst.equals("bool"))){
                            //System.out.println("tipo de la función permitida");
                            RESULT = "dir:"+ tst;
                        }else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                             ", columna " + (cur_token.right) +": "  + "Este tipo de función no es permitido: "+ tst);
                             RESULT = "dir:null";
                        }
                    :}
                    ;

//function int func3() | function int func3(string b1)
definirFunNav ::=  ayudaDefinirFuncionNavi:defin ABRECUENTO CIERRACUENTO 
                {:
                String[] partesOperando = defin.toString().split(":");
                RESULT = "dir:"+partesOperando[1];
                :}
                | ayudaDefinirFuncionNavi:defin ABRECUENTO ayudaDefFunNav CIERRACUENTO 
                {:
                String[] partesOperando = defin.toString().split(":");
                RESULT = "dir:"+partesOperando[1];
                :}
                | error FINREGALO 
                | error CIERRAREGALO
                | error ABREREGALO
                ;

// Definición completa de la función
bolsanavidenia ::= definirFunNav:defin
                //{:System.out.println("es ayudafed: "+defin);:}
                | definirFunNav:defin cuerpo:cuer
                
                {:
                //System.out.println("es ayudafed: "+defin);
                //System.out.println("es cuerpo: "+ cuer);
                String[] partesOperando1 = defin.toString().split(":");
                String[] partesOperando2 = cuer.toString().split(":");
                if(!(partesOperando1[1].equals(partesOperando2[1]))){
                    System.out.println("Error Semántico: El retorno de la función no cumple con su tipo esperado de salida");
                }
                :};

pbolsanavideniaAux ::=  bolsanavidenia
                    | pbolsanavideniaAux bolsanavidenia;


// Símbolo inicial con el que empieza la gramática
navidad ::= {:
                System.out.println("Empieza el asunto");
                :} 
                pbolsanavideniaAux
                {:
                imprimirTablaSimbolos();
                System.out.println("Termina el asunto");
                :};


//funcion main
/*cuerpoMain ::= ABREREGALO regaloExtn CIERRAREGALO;

entregaRegalos ::= {:
                    System.out.println("Empieza el asunto");
                    :} 
                    EMPEZONAVIDAD VIEJITOPASCUERO ENTREGAREGALOS ABRECUENTO CIERRACUENTO cuerpoMain 
                    {:
                    imprimirTablaSimbolos();
                    System.out.println("Termina el asunto");
                    :};
*/

//Produccion de expresiones
regalo ::= poloNorte:poli1 
            {:
                if (poli1 != null) {
                    //System.out.println("esto es poli1:" + poli1);
                    RESULT = poli1;
                } else {
                    //System.out.println("poli1 es null");
                    RESULT = "dir:null";
                }
            :}    
            | regalo:reg poloNorte:poli2
            {:
                //System.out.println("esto es regalo:" + reg);
                //System.out.println("esto es poli2:" + poli2);
                RESULT = poli2;
            :} 
            ;

antartica ::= bolsanavidenia | poloNorte;

regaloExtn ::= antartica
            | regaloExtn antartica;
