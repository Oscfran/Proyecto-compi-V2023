package ParserLexer;
import java_cup.runtime.*;

// Tabla de símbolos
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;

action code {:

    // Definición del HashMap
    HashMap<String, ArrayList<String>> listaTablaSimbolos = new HashMap<String, ArrayList<String>>();
    String currentHash;
     
    // Función para imprimir la tabla de símbolos
    public void imprimirTablaSimbolos(){
        for (String key: listaTablaSimbolos.keySet()){
            System.out.println("Tabla de simbolo: " + key);
            System.out.println("La tabla contiene estos valores: ");
            for(String item: listaTablaSimbolos.get(key)){
                System.out.println(item);
            }
            System.out.println("");
        }
    }

    // Agarra el tipo del token en la tabla de símbolos
    public String getTipo(ArrayList<String> tablasSimbolos, String id){
        String tipo = "null";
        for(String token : tablasSimbolos){
            String[] partesToken = token.split(":");
            if(id.equals(partesToken[2])){
                tipo = partesToken[3];
            }
        }
        System.out.println("tipo: "+tipo);
        return tipo;
    }
:}

parser code {:
    //Conectar parser a un escaner
    LexerJflex lex;

    @SuppressWarnings(value = { "deprecation" })
    public parser(LexerJflex lex){
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }

    //Manejo de errores
    public void syntax_error(Symbol cur_token) {
    System.err.println("Error sintáctico en la línea " + (cur_token.left+1) + 
                       ", columna " + (cur_token.right));
    }
    
    //Errores no recuperables
    public void unrecovered_syntax_error(Symbol cur_token) {
        if (cur_token.sym == sym.EOF) {
            System.err.println("Se alcanzó el final del archivo.");
        } else {
            System.err.println("Error de sintaxis irrecuperable en la línea " + (cur_token.left + 1) + 
                            ", columna " + (cur_token.right + 1) + ". Se terminó el archivo.");
        }
    }
:}

init with {: :};
scan with {: return lex.next_token(); :};

/* Lexer navideño */
terminal            EMPEZONAVIDAD, FESTIVAL, FIESTA, PERSONA, l_SANTA , l_SANTA_CLAUS, l_PAPANOEL, l_PASCUERO, l_COLACHO, ENTREGA, ELFO1, ELFO2, ELFO3, ELFO4, ELFO5, ELFO6;
terminal            GRINCH, QUIEN, RODOLFO, COMETA, BAILARIN, CUPIDO, DONNER, DASHER, ELFO, HADA, DUENDE, ENVUELVE, ENVOLTURA, HACE, REVISA, ENVIA, CORTA, MELCHOR, GASPAR, BALTASAR, POLO;
terminal            ABRECUENTO, CIERRACUENTO, ABREEMPAQUE, CIERRAEMPAQUE, ABREREGALO, CIERRAREGALO, FINREGALO, SANTACLAUS, PAPANOEL, SANNICOLAS, SINTERKLASS, VIEJITOPASCUERO, COLACHO;
terminal            ENTREGAREGALOS, MUERDAGO, NARRA, ESCUCHA, SANTACLAUSULA;

/* No terminales */
non terminal            poloNorte, t_santas, literales_navidenios, literal_no_nums, literal_nums, bolsanavidenia, pNocheBuena, pbolsanavideniaAux, narraNavidad, escuchaNavidad, entregaRegalos;
non terminal            grinchYQuien, unidadNavidenia, logisticadeNavidad, reyesMagos, regalo, cuerpo, ayudanteDeSanta, ayudaDefFunNav, definirFunNav, corta;
non terminal            elfos, creaRegalo, estructura, exprUni, exprP, exprArit, exprRelLog, exprRelAux, exprLogAux, operando, operandoRel, operandoLog;
non terminal            opciones, creaRegaloAssign, whileStmt, forStmt, cuerpoMain, regaloExtn, antartica, doWhileStmt, envia, elfoStm, hadaStm, duendeStm, renos;
non terminal            decl_G, ayudaDefinirFuncionNavi, llamadaNavidenia, llamadaNavideniaAux, ids, accesoArray, arrayDeclaration, arrayInitialization, listaExpresiones;

//Precedence
precedence left RODOLFO, COMETA;
precedence left BAILARIN, CUPIDO;
precedence left DONNER, DASHER;
precedence left QUIEN, GRINCH;

precedence left ELFO1,
                ELFO2,
                ELFO3,
                ELFO4,
                ELFO5,
                ELFO6;

precedence left MELCHOR;
precedence left GASPAR;
precedence left BALTASAR;

/* Inicio */
start with pNocheBuena;

//Grupos de literales
literales_navidenios ::= l_SANTA:lst {:RESULT = lst + "int";:} 
                    | l_SANTA_CLAUS:lst {:RESULT = lst + "bool";:} 
                    | l_PAPANOEL:lst {:RESULT = lst + "string";:} 
                    | l_PASCUERO:lst {:RESULT = lst + "float";:} 
                    | l_COLACHO:lst {:RESULT = lst + "char";:};

literal_nums ::= l_SANTA:lst {:RESULT = lst + "int";:} 
            | l_PASCUERO:lst {:RESULT = lst + "float";:};

literal_no_nums ::= l_SANTA_CLAUS:lst {:RESULT = lst + "bool";:} 
                | l_PAPANOEL:lst {:RESULT = lst + "string";:};

//print
narraNavidad ::= NARRA ABRECUENTO operando CIERRACUENTO FINREGALO;

//read
escuchaNavidad ::= ESCUCHA ABRECUENTO operando CIERRACUENTO FINREGALO;

//Tipos
t_santas ::= SANTACLAUS:tst {:RESULT = tst;:} 
            | PAPANOEL:tst {:RESULT = tst;:} 
            | SANNICOLAS:tst {:RESULT = tst;:}
            | SINTERKLASS:tst {:RESULT = tst;:} 
            | VIEJITOPASCUERO:tst {:RESULT = tst;:} 
            | COLACHO:tst {:RESULT = tst;:}
            | SANTACLAUSULA:tst {:RESULT = tst;:};


//return
envia ::= ENVIA operando FINREGALO;

//Break
corta ::= CORTA FINREGALO;

// Operadores generales: ==, !=
elfos ::= ELFO1:elfg | ELFO2:elfg | ELFO3:elfn | ELFO4:elfn | ELFO5:elfn | ELFO6:elfn;

/*

// Regla que ayuda a las operaciones relacionales
compN ::= literal_nums:lst
        | PERSONA:per 
        ;

// Operaciones relacionales que sólo permiten enteros o flotantes(>, <, >= <_)  
comp_elfosN ::= compN:operR1 elfos_nums:elfn compN:operR2;


// Regla que ayuda a las operaciones generales 
compG ::= literales_navidenios:lst
        {:
        String[] partesOperando = lst.toString().split(":");
        if (partesOperando[1].equals("int") || partesOperando[1].equals("float")  || partesOperando[1].equals("bool")){
            RESULT = "dir:" + partesOperando[1]; //Esto es para la generación de código destino que se ocupa la dirección, no sé qué más hacer.
            System.out.println("Acá entró y funcionó la validación general 1111"); 
        }else{
            RESULT = "dir:null";
            System.out.println("Error semántico en la línea "+ (cur_token.left+1) + 
                       ", columna " + (cur_token.right) + " tipo no permitido del literal " + partesOperando[1]);
       }
       :}
        | PERSONA:per 
        {:
        ArrayList<String> ts = listaTablaSimbolos.get(currentHash);
        String tipoId = getTipo(ts,per.toString());
        if (tipoId.equals("int") || tipoId.equals("float")|| tipoId.equals("bool")){
            RESULT = "dir:"+tipoId; //Esto es para la generación de código destino (Mips) que se ocupa la dirección, no sé qué más hacer.
            System.out.println("Acá entró y funcionó la validación general 222");
        }else{
            RESULT = "dir:null";
            System.out.println("Error semántico en la línea "+ (cur_token.left+1) + 
                       ", columna " + (cur_token.right) + "tipo no permitido del id " + per);
       }
       :}
        ;

// Operaciones generales(==, !=) y sólo permiten enteros, flotantes y booleanos
comp_elfosG ::= compG:opcomg1 elfos:elfg literales_navidenios:lst 
        {:
                // Segundo operando
                String[] partesOperando2 = lst.toString().split(":");
                String tOp2 = "null";
                if (!(partesOperando2[1].equals("int") || partesOperando2[1].equals("float")  || partesOperando2[1].equals("bool"))){
                    RESULT = "dir:null";
                    System.out.println("Error semántico en la línea "+ (cur_token.left+1) + 
                            ", columna " + (cur_token.right) + " tipo no permitido del literal " + partesOperando2[0]);
                }else{
                    tOp2 = partesOperando2[1];
                    RESULT = "dir:" + tOp2; //Esto es para la generación de código destino que se ocupa la dirección, no sé qué más hacer.
                    System.out.println("Acá entró y funcionó la validación general 1111");
            }

            // Primer Operando
            String[] partesOperando1 = opcomg1.toString().split("!");
            if(partesOperando1[1].equals(tOp2) && !(tOp2.equals("null"))){
                //Genero código de la operación comparación MIPS
                RESULT = "dir:" + tOp2;
            }else{
                    if(!(partesOperando1[1].equals("null")) && !(tOp2.equals("null"))){
                        System.out.println("Error semántico en la línea "+ (cur_token.left+1) + 
                            ", columna " + (cur_token.right) + "Los tipos de los operandos"  + partesOperando1[1] +  "y" + partesOperando1[1] + "no son iguales ");
                    }
                RESULT = "dir:null";
            }
       :}
        | compG:opcomg1 elfos:elf PERSONA:per

        {:
            ArrayList<String> ts = listaTablaSimbolos.get(currentHash);
            String tOp2 = getTipo(ts,per.toString());
                if (tOp2.equals("int") || tOp2.equals("float")|| tOp2.equals("bool")){
                    //Esto es para la generación de código destino (Mips) que se ocupa la dirección, no sé qué más hacer.
                    System.out.println("Acá entró y funcionó la validación general 222");
                }else{
                    RESULT = "dir:null";
                    System.out.println("Error semántico en la línea "+ (cur_token.left+1) + 
                       ", columna " + (cur_token.right) + "tipo no permitido del id " + per);
                }       

            // Primer Operando
            String[] partesOperando1 = opcomg1.toString().split("!");
            if(partesOperando1[1].equals(tOp2) && !(tOp2.equals("null"))){
                //Genero código de la operación comparación MIPS
                RESULT = "dir:" + tOp2;
            }else{
                if(!(partesOperando1[1].equals("null")) && !(tOp2.equals("null"))){
                    System.out.println("Error semántico en la línea "+ (cur_token.left+1) + 
                        ", columna " + (cur_token.right) + "Los tipos de los operandos"  + partesOperando1[1] +  "y" + partesOperando1[1] + "no son iguales ");
                }
                RESULT = "dir:null";
            }
       :}
       ;
*/

// Operadores aritméticos -, +, *, /, ~, **
renos ::= COMETA:rn    {:RESULT = rn;:}
         | RODOLFO:rn  {:RESULT = rn;:} 
         | BAILARIN:rn {:RESULT = rn;:} 
         | CUPIDO:rn   {:RESULT = rn;:} 
         | DONNER:rn   {:RESULT = rn;:} 
         | DASHER:rn   {:RESULT = rn;:};


// Operaciones aritméticas (obsoleto)
/*regaloprin ::= COMETA regaloprin
       | BALTASAR regaloprin
       | regaloprin renos:rn regaloprin
       | ABRECUENTO regaloprin CIERRACUENTO
       | literales_navidenios:lst 
       {:
       String [] partesOperando = lst.toString().split(":");
       if (partesOperando[1].equals("int") || partesOperando[1].equals("float")){
        RESULT = "dir:"+partesOperando[1]; //Esto es para la generación de código destino que se ocupa la dirección, no sé qué más hacer. 
       }else{
        RESULT = "dir:null";
        System.out.println("Error semántico en la línea "+ (cur_token.left+1) + 
                       ", columna " + (cur_token.right) + "tipo no permitido del literal " + partesOperando[0]);
       }
       :}

       | regaloprin logisticadeNavidad regaloprin
       | regaloprin unidadNavidenia regaloprin
       | regaloprin elfos regaloprin
       | regaloprin elfos_nums regaloprin
       | accesoArray
       | llamadaNavidenia
       | PERSONA:per
       {:
       ArrayList<String> ts = listaTablaSimbolos.get(currentHash);
       String tipoId = getTipo(ts,per.toString());
       if (tipoId.equals("int") || tipoId.equals("float")){
        RESULT = "dir:"+partesOperando[1]; //Esto es para la generación de código destino que se ocupa la dirección, no sé qué más hacer.
        System.out.println("Acá entró"); 
       }else{
        RESULT = "dir:null";
        System.out.println("Error semántico en la línea "+ (cur_token.left+1) + 
                       ", columna " + (cur_token.right) + "tipo no permitido del id " + per);
       }
       :}
       ;*/



// Operaciones aritméticas
exprUni ::= exprP FINREGALO;

exprP ::= exprArit | exprRelLog;

exprArit ::= COMETA operando
            | operando renos operando;

//Operadores unarios
unidadNavidenia ::= GRINCH | QUIEN;
grinchYQuien ::= unidadNavidenia operando;

exprRelLog ::= exprRelAux | exprLogAux;

exprRelAux ::= operando elfos operando;

//Operadores logicos
logisticadeNavidad ::= MELCHOR | GASPAR;
exprLogAux ::= BALTASAR operando
            | operando logisticadeNavidad operando;


operando ::= PERSONA | literales_navidenios | llamadaNavidenia | accesoArray | exprP | grinchYQuien | ABRECUENTO operando CIERRACUENTO;



//Declaracion de variables
//local int x <= 6|
creaRegalo ::= POLO t_santas:tst PERSONA:per FINREGALO{:
                listaTablaSimbolos.get(currentHash).add("tipo:Local:" + per.toString()+":"+ tst.toString());
                :}
                ;

creaRegaloAssign ::= POLO t_santas:tst PERSONA:per ENTREGA operando FINREGALO{:
                listaTablaSimbolos.get(currentHash).add("tipo:Local:" + per.toString()+":"+ tst.toString());
                :}
                | error FINREGALO
                ;
                
//asignacion de variables simplificado
decl_G ::= PERSONA ENTREGA operando FINREGALO;

cuerpo ::= ABREREGALO regalo CIERRAREGALO;


//arrays
//local int arr[3]|
arrayDeclaration ::= POLO t_santas:tst PERSONA ABREEMPAQUE operando CIERRAEMPAQUE FINREGALO
                    | error FINREGALO
                    ;

// Regla de inicialización de arrays
//int arr[3] <= {a,b,3}|
arrayInitialization ::= t_santas:tst PERSONA ABREEMPAQUE operando CIERRAEMPAQUE ENTREGA ABREREGALO listaExpresiones CIERRAREGALO FINREGALO 
                    | error FINREGALO
                    ;


listaExpresiones ::= operando
                 | listaExpresiones MUERDAGO operando;

//Acceso y asignacion array
//arr[1] ó  arr[3] <= 4|
accesoArray ::= PERSONA ABREEMPAQUE operando CIERRAEMPAQUE
            | PERSONA ABREEMPAQUE operando CIERRAEMPAQUE ENTREGA operando FINREGALO;

//Ciclos

//While
//while ( i <_ 5 ){}
whileStmt ::= ENVOLTURA ABRECUENTO operando CIERRACUENTO cuerpo;

//do until (do while)
//do{ cuerpo }until ( i <_ 5 )|
doWhileStmt ::= HACE cuerpo REVISA ABRECUENTO operando CIERRACUENTO FINREGALO;

//For 
//for(x=2,x<20,++x)
forStmt ::= ENVUELVE ABRECUENTO PERSONA ENTREGA l_SANTA:lst  MUERDAGO exprRelLog MUERDAGO grinchYQuien CIERRACUENTO cuerpo
            | ENVUELVE ABRECUENTO PAPANOEL PERSONA ENTREGA l_SANTA MUERDAGO exprRelLog MUERDAGO grinchYQuien CIERRACUENTO cuerpo
            | ENVUELVE ABRECUENTO POLO PAPANOEL PERSONA ENTREGA operando MUERDAGO exprRelLog MUERDAGO grinchYQuien CIERRACUENTO cuerpo;

//if - elif - else
//if
elfoStm::= ELFO ABRECUENTO operando CIERRACUENTO cuerpo;

//elif
hadaStm::= HADA ABRECUENTO operando CIERRACUENTO cuerpo;

//else
duendeStm ::= DUENDE cuerpo;

estructura ::= whileStmt 
                | forStmt 
                | doWhileStmt 
                | elfoStm 
                | hadaStm 
                | duendeStm;

//Funciones 

//Llamada de funciones
//hola()
//adios(intx, in)|
//error al poner funcion al final de una expresioncon final de linea ocupa doble final de linea para funcionar
ids ::= operando
    | ids MUERDAGO operando;
    
llamadaNavidenia ::= PERSONA ABRECUENTO CIERRACUENTO
                  |  PERSONA ABRECUENTO ids CIERRACUENTO;

llamadaNavideniaAux ::= llamadaNavidenia FINREGALO;

// Parámetro 
ayudanteDeSanta ::= t_santas:tst PERSONA:per
                {:
                if (!listaTablaSimbolos.containsKey(currentHash)) {
                listaTablaSimbolos.put(currentHash, new ArrayList<String>());
                }
                listaTablaSimbolos.get(currentHash).add("tipo:param:" + per.toString()+":"+ tst.toString());
                :}
                | PERSONA:per
                {:
                if (!listaTablaSimbolos.containsKey(currentHash)) {
                listaTablaSimbolos.put(currentHash, new ArrayList<String>());
                }
                listaTablaSimbolos.get(currentHash).add("tipo:param:" + per.toString());
                :};

// Varios parámetros
ayudaDefFunNav ::= ayudanteDeSanta
                    | ayudaDefFunNav MUERDAGO ayudanteDeSanta;



// Ayuda para la definición de funciones
ayudaDefinirFuncionNavi ::= EMPEZONAVIDAD t_santas:tsc PERSONA:per
                        {:
                        currentHash = per.toString();
                        String tipoTabla = "main";
                        if (per.toString().equals("main"))
                            tipoTabla = "tipo:main:"+tsc.toString();
                        else
                            tipoTabla = "tipo:function:"+tsc.toString();
                        ArrayList<String> funcionMain = new ArrayList<String>();
                        funcionMain.add(tipoTabla);
                        listaTablaSimbolos.put(currentHash, funcionMain);
                        :}
                        ;

//Definición de funciones
definirFunNav ::=  ayudaDefinirFuncionNavi ABRECUENTO CIERRACUENTO 
                | ayudaDefinirFuncionNavi ABRECUENTO ayudaDefFunNav CIERRACUENTO 
                | error FINREGALO 
                | error CIERRAREGALO
                | error ABREREGALO
                ;

bolsanavidenia ::= definirFunNav
                | definirFunNav cuerpo;

pbolsanavideniaAux ::=  bolsanavidenia
                    | pbolsanavideniaAux bolsanavidenia;

pNocheBuena ::= {:
                System.out.println("Empieza el asunto");
                :} 
                pbolsanavideniaAux
                {:
                imprimirTablaSimbolos();
                System.out.println("Termina el asunto");
                :};


//funcion main
/*cuerpoMain ::= ABREREGALO regaloExtn CIERRAREGALO;

entregaRegalos ::= {:
                    System.out.println("Empieza el asunto");
                    :} 
                    EMPEZONAVIDAD VIEJITOPASCUERO ENTREGAREGALOS ABRECUENTO CIERRACUENTO cuerpoMain 
                    {:
                    imprimirTablaSimbolos();
                    System.out.println("Termina el asunto");
                    :};
*/

//Encapsula todas las expresiones para que se puedan colocar dentro de las funciones
poloNorte  ::=  decl_G 
                | creaRegalo
                | creaRegaloAssign
                | narraNavidad 
                | estructura
                | envia 
                | exprUni
                | escuchaNavidad
                | corta
                | llamadaNavideniaAux;

//Produccion de expresiones
regalo ::= poloNorte
            | regalo poloNorte;

antartica ::= bolsanavidenia | poloNorte;

regaloExtn ::= antartica
            | regaloExtn antartica;