package ParserLexer;
import java_cup.runtime.*;

// Tabla de símbolos
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import java.io.FileWriter;
import java.io.BufferedWriter;
import java.io.IOException;

action code {:

    // Definición del HashMap
    HashMap<String, ArrayList<String>> listaTablaSimbolos = new HashMap<String, ArrayList<String>>();
    String currentHash;
    String hashPrevio;
    String data = ".data\nhelloworld: .asciiz \"Hello World!\"\n";
    int nData = 0;
    String codigoMIPS = "exit:\n\tli $v0, 10\n\tsyscall\n\n";
    String funP = "\nmain:\n";
    
    public int getnData(){
        return nData;
    }
    // Función para imprimir la tabla de símbolos
    public void imprimirTablaSimbolos(){
        for (String key: listaTablaSimbolos.keySet()){  
            System.out.println("\nLa tabla contiene estos valores: ");
            System.out.println("Tabla de simbolo: " + key);
            for(String item: listaTablaSimbolos.get(key)){
                System.out.println(item);
            }
            System.out.println("");
        }
    }

    // Agarra el tipo del token en la tabla de símbolos
    public String getTipo(ArrayList<String> tablasSimbolos, String id){
        String tipo = "null";
        for(String token : tablasSimbolos){
            String[] partesToken = token.split(":");
            if(id.equals(partesToken[2])){
                //System.out.println("Nombre variable:" + partesToken[2]  + " tipo: " + tipo);
                tipo = partesToken[3];
                
            }
        }
        return tipo;
    }

    //Data
    public void addData(String cadena){
        data += ( "m" + nData ) + ": .asciiz " + cadena +"\n";
        nData++;
    }
    public void addFunp(String cadena){
        funP += cadena;
    }

    // Generación de código MIPS
    public void generarCodigoMIPS(String codigo){
        codigoMIPS += codigo;
    }

    // Función para escribir el código MIPS en un archivo
    public void escribirCodigoMIPSEnArchivo() throws IOException {
        BufferedWriter writer = new BufferedWriter(new FileWriter("src\\resultadoASM\\salida.asm"));
        writer.write(data + "\n\n.text\n");
        writer.write(codigoMIPS+"\tj exit");
        writer.write(funP);
        writer.write("\tj exit");
        writer.flush();
    }

    public String getNombre(ArrayList<String> tablasSimbolos, String id){
        String nombre = "null";
        for(String token : tablasSimbolos){
            String[] partesToken = token.split(":");
            if(id.equals(partesToken[2])){
                nombre = partesToken[2];
                
            }
        }
        return nombre;
    }
:}

parser code {:
    //Conectar parser a un escaner
    LexerJflex lex;

    @SuppressWarnings(value = { "deprecation" })
    public parser(LexerJflex lex){
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }

    //Manejo de errores
    public void syntax_error(Symbol cur_token) {
    System.err.println("Error sintáctico en la línea " + (cur_token.left+1) + 
                       ", columna " + (cur_token.right));
    }
    
    //Errores no recuperables
    public void unrecovered_syntax_error(Symbol cur_token) {
        if (cur_token.sym == sym.EOF) {
            System.err.println("Se alcanzó el final del archivo.");
        } else {
            System.err.println("Error de sintaxis irrecuperable en la línea " + (cur_token.left + 1) + 
                            ", columna " + (cur_token.right + 1));
        }
    }
:}

init with {: :};
scan with {: return lex.next_token(); :};

/* Lexer navideño */
terminal            EMPEZONAVIDAD, PERSONA, l_SANTA , l_SANTA_CLAUS, l_PAPANOEL, l_PASCUERO, l_COLACHO, ENTREGA, ELFO1, ELFO2, ELFO3, ELFO4, ELFO5, ELFO6;
terminal            GRINCH, QUIEN, RODOLFO, COMETA, BAILARIN, CUPIDO, DONNER, DASHER, ELFO, HADA, DUENDE, ENVUELVE, ENVOLTURA, HACE, REVISA, ENVIA, CORTA, MELCHOR, GASPAR, BALTASAR, POLO;
terminal            ABRECUENTO, CIERRACUENTO, ABREEMPAQUE, CIERRAEMPAQUE, ABREREGALO, CIERRAREGALO, FINREGALO, SANTACLAUS, PAPANOEL, SANNICOLAS, SINTERKLASS, VIEJITOPASCUERO, COLACHO;
terminal            MUERDAGO, NARRA, ESCUCHA, SANTACLAUSULA, CUPIENTERO, GALLETAQUIETA, ENTREGAREGALOS;

/* No terminales */
non terminal            poloNorte, navidad,t_santas, literales_navidenios, bolsanavidenia, pbolsanavideniaAux, narraNavidad, escuchaNavidad;
non terminal            grinchYQuien, unidadNavidenia, logisticadeNavidad, regalo, cuerpo, ayudanteDeSanta, ayudaDefFunNav, definirFunNav, corta;
non terminal            elfos, creaRegalo, estructura, exprUni, exprP, regaloprin, regaloCompradoLogRel, regaloCompradoAux, regaloManualAux, operando, operandoLog;
non terminal            opciones,creaRegaloAssign, forStmt, cuerpoMain, regaloExtn, antartica, doUntilStmt, envia, elfoStm, hadaStm, hadaMulti, duendeStm, renos;
non terminal            decl_G, ayudaDefinirFuncionNavi, llamadaNavidenia, llamadaNavideniaAux, ids, accesoArray, arrayDeclaration, arrayInitialization, listaExpresiones;

//Precedence
precedence left RODOLFO, COMETA;
precedence left BAILARIN, CUPIDO, CUPIENTERO;
precedence left DONNER, DASHER;
precedence left QUIEN, GRINCH;

precedence left ELFO1,
                ELFO2,
                ELFO3,
                ELFO4,
                ELFO5,
                ELFO6;

precedence left MELCHOR;
precedence left GASPAR;
precedence left BALTASAR;

/* Inicio */
start with navidad;

//Grupos de literales
literales_navidenios ::= l_SANTA:lst {:RESULT = lst + ":int";:} 
                    | l_SANTA_CLAUS:lst {:RESULT = lst + ":bool";:} 
                    | l_PAPANOEL:lst {:RESULT = lst + ":string";:} 
                    | l_PASCUERO:lst {:RESULT = lst + ":float";:} 
                    | l_COLACHO:lst {:RESULT = lst + ":char";:};

//Tipos
t_santas ::= SANTACLAUS:tst {:RESULT = tst;:}       //string,
            | PAPANOEL:tst {:RESULT = tst;:}        //int
            | SANNICOLAS:tst {:RESULT = tst;:}      //float
            | SINTERKLASS:tst {:RESULT = tst;:}     //double
            | VIEJITOPASCUERO:tst {:RESULT = tst;:} //void
            | COLACHO:tst {:RESULT = tst;:}         //char
            | SANTACLAUSULA:tst {:RESULT = tst;:};  //bool

// Operadores de comparación
elfos ::= ELFO1:elf {:RESULT = elf;:}// ==
        | ELFO2:elf {:RESULT = elf;:}// !=
        | ELFO3:elf {:RESULT = elf;:}// >
        | ELFO4:elf {:RESULT = elf;:}// <
        | ELFO5:elf {:RESULT = elf;:}// =>
        | ELFO6:elf {:RESULT = elf;:};// =<

// Operadores aritméticos
renos ::= COMETA:rn    {:RESULT = rn;:} // -
         | CUPIENTERO:rn {:RESULT = rn;:} // // Esta es la que puse para la divisón entera/Así da shift reduce
         | RODOLFO:rn  {:RESULT = rn;:} // +
         | BAILARIN:rn {:RESULT = rn;:} // *
         | CUPIDO:rn   {:RESULT = rn;:} // /
         | DONNER:rn   {:RESULT = rn;:} // ~
         | DASHER:rn   {:RESULT = rn;:}; // **

//Operadores unarios
unidadNavidenia ::= GRINCH:gr {:RESULT = gr;:} //++
                 | QUIEN:qn {:RESULT = qn;:}; //--

// Permite expresiones sin declaración (siempre dentro de la función)
exprUni ::= exprP:pr FINREGALO
            {:
            String[] partesOperando = pr.toString().split(":");
                if(!(partesOperando[1].equals("null"))){
                    RESULT = "dir:"+ partesOperando[1];
                }
                else{
                    RESULT = "dir:null";
                } 
            :}
            | grinchYQuien:gr FINREGALO
            {:
            String[] partesOperando = gr.toString().split(":");
                if(!(partesOperando[1].equals("null"))){
                    RESULT = "dir:"+ partesOperando[1];
                }
                else{
                    RESULT = "dir:null";
                } 
            :}
            ;

// Expresión que junta operaciones aritméticas y relacionales
exprP ::= regaloprin:prin
        {:
            String[] partesOperando = prin.toString().split(":");
            if(!(partesOperando[1].equals("null"))){
                RESULT = "dir:"+ partesOperando[1];
            }else{
                RESULT = "dir:null";
            }
        :} 
        | regaloCompradoLogRel:prlog
        {:  
            //System.out.println("prlog es: "+prlog);
            String[] partesOperando = prlog.toString().split(":");
            if(prlog != null || !(partesOperando[1].equals("null"))){
                RESULT = "dir:"+partesOperando[1];
            }
            else{
                RESULT = "dir:null";
            }
        :}
        ;

// Operación aritmética
regaloprin ::= COMETA operando:oper3 
            {:
                String[] partesOperando = oper3.toString().split(":");
                if(partesOperando[1].equals("int") || partesOperando[1].equals("float") ){
                    RESULT = "dir:"+partesOperando[1];  
                }else{
                    RESULT = "dir:null";
                }
            :}
            | operando:oper1 renos:rn operando:oper2        
            {:
                String[] partesOperando1 = oper1.toString().split(":");
                String[] partesOperando2 = oper2.toString().split(":");

                if(rn.equals("/")){
                    if(partesOperando1[1].equals(partesOperando2[1])){
                        if(partesOperando1[1].equals("float")){
                            System.out.println("Es división flotante");
                            RESULT = "dir:"+partesOperando1[1];
                        }
                        else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) +
                                ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos no son del tipo permitido: " + partesOperando1[1] + ", " + partesOperando2[1]);
                            RESULT = "dir:null";
                        }
                    }
                    else{
                        System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                            ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos no son iguales: " + partesOperando1[1] + ", " + partesOperando2[1]);
                        RESULT = "dir:null";
                    }
                }   
                else if(rn.equals("//")){
                    if(partesOperando1[1].equals(partesOperando2[1])){
                        if(partesOperando1[1].equals("int")){
                            System.out.println("Es división entera");
                            RESULT = "dir:"+partesOperando1[1];
                        }
                        else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                                ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos no son del tipo permitido: " + partesOperando1[1] + ", " + partesOperando2[1]);
                            RESULT = "dir:null";
                        }
                    }
                    else{
                        System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                            ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos no son iguales: " + partesOperando1[1] + ", " + partesOperando2[1]);
                        RESULT = "dir:null";
                    }
                }
                else{  
                    if(partesOperando1[1].equals(partesOperando2[1])){
                        if(partesOperando1[1].equals("int") || partesOperando1[1].equals("float")){
                                RESULT = "dir:"+partesOperando1[1];
                                System.out.println(oper2.toString());
                                if (partesOperando1.length > 2 && partesOperando2.length > 2){
                                    if(rn.equals("+")){
                                        ArrayList<String> ts = listaTablaSimbolos.get(currentHash);
                                        generarCodigoMIPS("lw $t0, " + partesOperando1[2] + "\n" + "lw $t1, " + partesOperando2[2] + "\n" + "add $t2, $t0, $t1 \n");
                                    }
                                    else if (rn.equals("-")){
                                        generarCodigoMIPS("lw $t0, " + partesOperando1[2] + "\n" + "lw $t1, " + partesOperando2[2] + "\n" + "sub $t2, $t0, $t1 \n");
                                    }
                                    else if (rn.equals("*")){
                                        generarCodigoMIPS("lw $t0, " + partesOperando1[2] + "\n" + "lw $t1, " + partesOperando2[2] + "\n" + "mul $t2, $t0, $t1 \n");
                                    }
                                } 

                        }
                        else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                            ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos no son del tipo permitidos \n para las operaciones aritméticas: " + partesOperando1[1] + ", " + partesOperando2[1]);
                            RESULT = "dir:null";
                        }
                    }
                    else{
                        System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                            ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos no son iguales: " + partesOperando1[1] + ", " + partesOperando2[1]);
                        RESULT = "dir:null";
                        }
                    }     
            :}  
              ;



// ++i, ++persona, --persona
grinchYQuien ::= unidadNavidenia operando:oper1
            {:
            String[] partesOperando = oper1.toString().split(":");
            if(partesOperando[1].equals("int")){
                RESULT = "dir:"+partesOperando[1];  
            }else{
                RESULT = "dir:null";
                System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                            ", columna " + (cur_token.right) +": "  + "El tipo para su unario no es correcto");
                        RESULT = "dir:null";
            }
            :}
            ;


//Expresiones relacionales
regaloCompradoAux ::= operando:oper1 elfos:elf operando:oper2
            {:
            String[] partesOperando1 = oper1.toString().split(":");
            String[] partesOperando2 = oper2.toString().split(":");
                // Permite expresiones relacionales (==, !=) del mismo tipo, mientras que sean int, float y bool
                if((elf.equals("==") || elf.equals("!="))){
                    if (partesOperando1[1].equals(partesOperando2[1])){
                        if ((partesOperando1[1].equals("int") || partesOperando1[1].equals("float") || partesOperando1[1].equals("bool"))){
                            RESULT = "dir:bool"; // El resultado de estas operaciones es booleano
                        }
                        else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                                ", columna " + (cur_token.right) +": "  + "Los tipos de los operando no son permitidos, sólo int-float-bool: ");
                                 RESULT = "dir:null";
                        }
                    }
                    else{
                        System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                        ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos relacionales no son iguales: " + partesOperando1[1] + ", " + partesOperando2[1]);
                        RESULT = "dir:null";
                    }
                }
                // Permite expresiones relacionales (<, >, =>, =<) del mismo tipo, mientras que sean int y float
                else{
                    if (partesOperando1[1].equals(partesOperando2[1])){
                        if (partesOperando1[1].equals("int") || partesOperando1[1].equals("float")){
                            RESULT = "dir:bool"; // El resultado de estas operaciones también es booleano
                        }
                        else{
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                                ", columna " + (cur_token.right) +": "  + "Los tipos de los operando no son permitidos i-f: ");
                                 RESULT = "dir:null";
                        }
                    }
                    else{
                        System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                        ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos relacionales no son iguales: " + partesOperando1[1] + ", " + partesOperando2[1]);
                        RESULT = "dir:null";
                    }
                }
            :}
            ;

// Combinación de expresiones lógicas y relacionales
regaloCompradoLogRel ::= regaloCompradoAux:relaux 
            {:
            //System.out.println("relaux es:" +relaux);
            if(relaux != null){
                RESULT = relaux;
            }
            else{
                RESULT = "dir:null";
            }
            :}
            | regaloManualAux:logaux
            {:
            //System.out.println("logaux es:" +logaux);
            if(logaux != null){
                RESULT = logaux;
            }
            else{
                RESULT = "dir:null";
            }
            :}
            ;

//Operadores logicos      # | ^
logisticadeNavidad ::= MELCHOR:mel {:RESULT = mel;:} 
                    | GASPAR:gal {:RESULT = gal;:};

// ! operando y operando # | ^ operando
regaloManualAux ::= BALTASAR operando:oper1
            {:
            String[] partesOperando = oper1.toString().split(":");
            if(oper1 != null || !(partesOperando[1].equals("null"))){
                RESULT = "dir:"+partesOperando[1];
            }
            else{
                RESULT = "dir:null";
            }
            :}
            | operando:oper1 logisticadeNavidad:logis operando:oper2
            {:
            String[] partesOperando1 = oper1.toString().split(":");
            String[] partesOperando2 = oper2.toString().split(":");
                if(partesOperando1[1].equals(partesOperando2[1])){
                    /*System.out.println("Los operandos de esta operación en la línea" + (cur_token.left+1) + 
                     ", columna " + (cur_token.right) +":"+"son del mismo tipo logico");*/
                    RESULT = "dir:"+partesOperando1[1];
                }else{
                    System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                        ", columna " + (cur_token.right) +": "  + "Los tipos de los operandos lógicos no son iguales: " + partesOperando1[1] + ", " + partesOperando2[1]);
                    RESULT = "dir:null";
                }
            :};


// Lo que sea que se vaya a operar más carga del tipo per y literal 
operando ::= PERSONA:per
        {:
            ArrayList<String> ts = listaTablaSimbolos.get(currentHash);
            String tipoId = getTipo(ts,per.toString());
            if(tipoId != "null"){
                RESULT = "dir:"+tipoId;
            }else{
                RESULT = "dir:null";
            }
        :}
        | literales_navidenios:lst 
        {:
            String[] partesOperando = lst.toString().split(":");
            if(partesOperando[1] != "null"){
                RESULT = "dir:"+partesOperando[1] + ":" + partesOperando[0]; 
            }else{
                RESULT = "dir:null";
            }
       :}
        | llamadaNavidenia 
        | accesoArray 
        | exprP:pr 
        {:
            //System.out.println("pr es:" +pr);
            String[] partesOperando = pr.toString().split(":");
            if(partesOperando[1] != "null"){
                RESULT = "dir:"+partesOperando[1] + ":" + partesOperando[0];
            }else{
                RESULT = "dir:null";
            }
        :}
        | grinchYQuien:gq
        {:
            //System.out.println("pr es:" +pr);
            String[] partesOperando = gq.toString().split(":");
            if(partesOperando[1] != "null"){
                RESULT = "dir:"+partesOperando[1];  
            }else{
                RESULT = "dir:null";
            }
        :}
        | ABRECUENTO operando:ope CIERRACUENTO
        {:
            //System.out.println("pr es:" +pr);
            String[] partesOperando = ope.toString().split(":");
            if(partesOperando[1] != "null"){
                RESULT = "dir:"+partesOperando[1];  
            }else{
                RESULT = "dir:null";
            }
        :}
        ;

//Declaracion de variable sin asignación
//local tipo arroz|
creaRegalo ::= POLO t_santas:tst PERSONA:per FINREGALO
              {:
              ArrayList<String> detallesFuncion = listaTablaSimbolos.get(currentHash);
              String nombreVariableLocal = "tipo:Local:" + per.toString();

              // Verificar si el nombre de la variable local ya existe en la lista, independientemente del tipo
              boolean variableYaDeclarada = detallesFuncion.stream()
                                              .anyMatch(v -> v.startsWith(nombreVariableLocal));

              if (!variableYaDeclarada) {
                  String nuevaVariableLocal = nombreVariableLocal + ":" + tst.toString();
                  detallesFuncion.add(nuevaVariableLocal);

                  if (!tst.equals("null")) {
                      // Variable bien declarada
                      RESULT = "dir:" + tst;
                  } else {
                      // Error si el tipo es 'null'
                      System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                                         ", columna " + (cur_token.right) + ": Mal declarada la variable sin asignación");
                      RESULT = "dir:null";
                  }
              } else {
                  // Error si la variable local ya fue declarada
                  System.err.println("Error semántico en la línea" + (cur_token.left) + 
                            ", columna " + (cur_token.right) +":" +" Variable '" + per.toString() + "' ya declarada en el ámbito actual.");
                  RESULT = "dir:null";
              }
              :}
              | error EMPEZONAVIDAD
              ;

// Declaración de variable con asignación
//local tipo arroz <= 14|
creaRegaloAssign ::= POLO t_santas:tst PERSONA:per ENTREGA operando:oper1 FINREGALO
                    {:
                    ArrayList<String> detallesFuncion = listaTablaSimbolos.get(currentHash);
                    String nombreVariableLocal = "tipo:Local:" + per.toString();

                    // Verificar si el nombre de la variable local ya existe en la lista
                    boolean variableYaDeclarada = detallesFuncion.stream()
                                                    .anyMatch(v -> v.startsWith(nombreVariableLocal));

                    if (!variableYaDeclarada) {
                        String nuevaVariableLocal = nombreVariableLocal + ":" + tst.toString();
                        detallesFuncion.add(nuevaVariableLocal);

                        // Se verifica el tipo de la variable
                        if (!tst.equals("null")) {
                            String[] partesOperando = oper1.toString().split(":");
                            if (tst.equals(partesOperando[1])) {
                                // El tipo de la variable coincide con su asignación
                                RESULT = "dir:" + tst;
                            } else {
                                // Error si el tipo de la variable no coincide con el tipo de su asignación
                                System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                                   ", columna " + (cur_token.right) + ":" + 
                                                   " Tipo de la variable no coincide con su tipo de asignación");
                                RESULT = "dir:null";
                            }
                        } else {
                            // Error si el tipo es 'null'
                            System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                               ", columna " + (cur_token.right) + ":" + 
                                               " Tipo de la variable vacía");
                            RESULT = "dir:null";
                        }
                    } else {
                        // Error si la variable local ya fue declarada
                        System.err.println("Error semántico en la línea" + (cur_token.left) + 
                            ", columna " + (cur_token.right) +":" +" Variable '" + per.toString() + "' ya declarada en el ámbito actual.");
                        RESULT = "dir:null";
                    }
                    :}
                    | error ELFO
                    ;

                
//Redeclaración de variables
decl_G ::= PERSONA ENTREGA operando FINREGALO;

cuerpo ::= ABREREGALO CIERRAREGALO
        | ABREREGALO regalo:reg CIERRAREGALO
        {:
            if(reg != null){
                String[] partesOperando = reg.toString().split(":");
                if(!(partesOperando[1].equals("null"))){
                    RESULT = "dir:"+ partesOperando[1];
                }else{
                    RESULT = "dir:null";
                }
            }
        :}
        ;


// Producción para la declaración inicial del array con |, pueden ser estáticas o no.
//local int arr[3]|
//local char arr[3]|
//local static int array[2]|
//local static char array[2]|
arrayDeclaration ::= POLO t_santas:tst PERSONA:per ABREEMPAQUE l_SANTA:lst CIERRAEMPAQUE FINREGALO
                    {:
                    ArrayList<String> detallesFuncion = listaTablaSimbolos.get(currentHash);
                    String nombreArray = "tipo:Local:" + per.toString() + ":" + tst.toString();

                    // Verificar si el nombre del arreglo ya existe en la lista
                    if (!detallesFuncion.contains(nombreArray)) {
                        // Añadir el nuevo arreglo si no existe
                        detallesFuncion.add(nombreArray);

                        if (tst.equals("int") || tst.equals("char")) {
                            RESULT = "dir:" + tst;
                        } else {
                            System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                               ", columna " + (cur_token.right) + ":" + 
                                               "Tipo de iniciación de array incorrecto, sólo puede ser de tipo char o int");
                            RESULT = "dir:null";
                        }
                    } else {
                        // Error si el arreglo ya fue declarado
                        System.err.println("Error semántico: Arreglo '" + per.toString() + "' ya declarado en el ámbito actual.");
                        RESULT = "dir:null";
                    }
                    :}
                    | POLO GALLETAQUIETA:gaie t_santas:tst PERSONA:per ABREEMPAQUE l_SANTA:lst CIERRAEMPAQUE FINREGALO
                    {:
                    ArrayList<String> detallesFuncion = listaTablaSimbolos.get(currentHash);
                    String nombreArray = "tipo:Local:" + per.toString() + ":" + tst.toString();

                    // La misma verificación y lógica para la otra opción de declaración de arreglo
                    if (!detallesFuncion.contains(nombreArray)) {
                        detallesFuncion.add(nombreArray);

                        if (tst.equals("int") || tst.equals("char")) {
                            RESULT = "dir:" + tst;
                        } else {
                            System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                               ", columna " + (cur_token.right) + ":" + 
                                               "Tipo de iniciación de array incorrecto, sólo puede ser de tipo char o int");
                            RESULT = "dir:null";
                        }
                    } else {
                        System.err.println("Error semántico: Arreglo '" + per.toString() + "' ya declarado en el ámbito actual.");
                        RESULT = "dir:null";
                    }
                    :}
                    ;

// Regla de inicialización de arrays
//  local char arr[3] <= {'a'}|
//  local int arr[3] <= {45,3,1}|
//  local static char arr[3] <= {'a'}|
//  local static int arr[3] <= {45,3,1}|
arrayInitialization ::=  POLO t_santas:tst PERSONA:per ABREEMPAQUE l_SANTA:lst CIERRAEMPAQUE ENTREGA ABREREGALO listaExpresiones:lisexpr CIERRAREGALO FINREGALO
                    {:
                       ArrayList<String> detallesFuncion = listaTablaSimbolos.get(currentHash);
                        String nombreArray = "tipo:Local:" + per.toString();

                        // Verificar si el nombre del arreglo ya existe en la lista
                        if (detallesFuncion.stream().noneMatch(s -> s.startsWith(nombreArray + ":"))) {
                            detallesFuncion.add(nombreArray + ":" + tst.toString());
                            String[] partesOperando = lisexpr.toString().split(":");

                            if(tst.equals("int")){  
                                // Validación e inicialización para arreglos de tipo 'int'
                                if((partesOperando[1].equals("int"))){
                                    if(tst.equals(partesOperando[1])){
                                        System.out.println("Tipo de array y contenido dentro de llaves parejo INT");
                                        RESULT = "dir:"+ partesOperando[1];
                                    }else{
                                        System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                        ", columna " + (cur_token.right) +":"  + "Tipo de array y contenido dentro de llaves incorrecto");
                                        RESULT = "dir:null";
                                    }
                                }else{
                                    System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                        ", columna " + (cur_token.right) +":"  + "Tipo de array y contenido dentro de llaves no concuerda");
                                    RESULT = "dir:null";
                                }
                            }
                            else if(tst.equals("char")){
                                // Validación e inicialización para arreglos de tipo 'char'
                                if((partesOperando[1].equals("char"))){
                                    if(tst.equals(partesOperando[1])){
                                        System.out.println("Tipo de array y contenido dentro de llaves parejo CHAR");
                                        RESULT = "dir:"+ partesOperando[1];
                                    }else{
                                        System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                        ", columna " + (cur_token.right) +":"  + "Tipo de array y contenido dentro de llaves incorrecto");
                                        RESULT = "dir:null";
                                    }
                                }else{
                                    System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                        ", columna " + (cur_token.right) +":"  + "Tipo de array y contenido dentro de llaves no concuerda");
                                    RESULT = "dir:null";
                                }
                            }
                            else{
                                System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                ", columna " + (cur_token.right) +":"  + "Tipo de iniciación de array incorrecto, sólo puede ser de tipo char o int");
                                RESULT = "dir:null";
                            }
                        } else {
                            System.err.println("Error semántico: Arreglo '" + per.toString() + "' ya declarado en el ámbito actual.");
                            RESULT = "dir:null";
                        }
                    :} 
                    | POLO GALLETAQUIETA:gaie t_santas:tst PERSONA:per ABREEMPAQUE l_SANTA:lst CIERRAEMPAQUE ENTREGA ABREREGALO listaExpresiones:lisexpr CIERRAREGALO FINREGALO
                    {:
                        ArrayList<String> detallesFuncion = listaTablaSimbolos.get(currentHash);
                        String nombreArray = "tipo:Local:" + per.toString();

                        // Verificar si el nombre del arreglo ya existe en la lista
                        if (detallesFuncion.stream().noneMatch(s -> s.startsWith(nombreArray + ":"))) {
                            detallesFuncion.add(nombreArray + ":" + tst.toString());
                            String[] partesOperando = lisexpr.toString().split(":");

                            if(tst.equals("int")){  
                                // Lógica para arreglos de tipo 'int'
                                if((partesOperando[1].equals("int"))){
                                    if(tst.equals(partesOperando[1])){
                                        RESULT = "dir:"+ partesOperando[1];
                                    }else{
                                        System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                        ", columna " + (cur_token.right) +":"  + "Tipo de array y contenido dentro de llaves incorrecto");
                                        RESULT = "dir:null";
                                    }
                                }else{
                                    System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                        ", columna " + (cur_token.right) +":"  + "Tipo de array y contenido dentro de llaves no concuerda");
                                    RESULT = "dir:null";
                                }
                            }
                            else if(tst.equals("char")){
                                // Lógica para arreglos de tipo 'char'
                                if((partesOperando[1].equals("char"))){
                                    if(tst.equals(partesOperando[1])){
                                        System.out.println("Tipo de array y contenido dentro de llaves parejo CHAR");
                                        RESULT = "dir:"+ partesOperando[1];
                                    }else{
                                        System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                        ", columna " + (cur_token.right) +":"  + "Tipo de array y contenido dentro de llaves incorrecto");
                                        RESULT = "dir:null";
                                    }
                                }else{
                                    System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                        ", columna " + (cur_token.right) +":"  + "Tipo de array y contenido dentro de llaves no concuerda");
                                    RESULT = "dir:null";
                                }
                            }
                            else{
                                System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                ", columna " + (cur_token.right) +":"  + "Tipo de iniciación de array incorrecto, sólo puede ser de char o int");
                                RESULT = "dir:null";
                            }
                        } else {
                            System.err.println("Error semántico: Arreglo '" + per.toString() + "' ya declarado en el ámbito actual.");
                            RESULT = "dir:null";
                        }
                    :} ;


// Regla para acompañar la asignación de arrays
listaExpresiones ::= operando:oper1
                {:
                    String[] partesOperando = oper1.toString().split(":");
                    if(partesOperando[1].equals("int")|| partesOperando[1].equals("char")){
                        RESULT = "dir:"+ partesOperando[1];
                    }else{
                        System.err.println("Error semántico en la línea " + (cur_token.left) + 
                            ", columna " + (cur_token.right) +":"  + "No llega cargado de ni de tipo int ni char");
                        RESULT = "dir:null";
                    }
                :}
                 | listaExpresiones:lsexpr MUERDAGO operando:oper2
                 {:
                    String[] partesOperando = oper2.toString().split(":");
                    if(partesOperando[1].equals("int")|| partesOperando[1].equals("char")){
                        RESULT = "dir:"+ partesOperando[1];
                    }else{
                        System.err.println("Error semántico en la línea " + (cur_token.left) + 
                            ", columna " + (cur_token.right) +":"  + "No llega cargado de ni de tipo int ni char");
                        RESULT = "dir:null";
                    }
                 :}
                 ;

//Acceso y asignacion array
//arr[1] ó  arr[3] <= 4|
accesoArray ::= PERSONA:per ABREEMPAQUE operando:oper1 CIERRAEMPAQUE
            | PERSONA:per ABREEMPAQUE operando:oper2 CIERRAEMPAQUE ENTREGA operando:oper3 FINREGALO
            ;

//Ciclos

//do until (do)
//do{ cuerpo }until ( i <_ 5 )|
doUntilStmt ::= HACE cuerpo REVISA ABRECUENTO operando CIERRACUENTO FINREGALO
;

//For 
//for(x=2,x<20,++x)
forStmt ::= ENVUELVE ABRECUENTO PERSONA ENTREGA l_SANTA:lst  MUERDAGO regaloCompradoLogRel MUERDAGO grinchYQuien CIERRACUENTO cuerpo
            | ENVUELVE ABRECUENTO PAPANOEL PERSONA ENTREGA l_SANTA MUERDAGO regaloCompradoLogRel MUERDAGO grinchYQuien CIERRACUENTO cuerpo
            | ENVUELVE ABRECUENTO POLO PAPANOEL PERSONA ENTREGA operando MUERDAGO regaloCompradoLogRel MUERDAGO grinchYQuien CIERRACUENTO cuerpo;

//if - elif - else
//if
elfoStm::= ELFO ABRECUENTO operando:oper1 CIERRACUENTO cuerpo:cuer1
            | ELFO ABRECUENTO operando:oper2 CIERRACUENTO cuerpo:cuer2 duendeStm //if y else
            | ELFO ABRECUENTO operando:oper3 CIERRACUENTO cuerpo:cuer3 hadaMulti //if n elifs
            | ELFO ABRECUENTO operando:oper4 CIERRACUENTO cuerpo:cuer4 hadaMulti duendeStm
            | error CIERRAREGALO
            ; //if n elifs y else

//elif
hadaStm ::= HADA ABRECUENTO operando:oper CIERRACUENTO cuerpo ;

//n elifs
hadaMulti ::= hadaStm
            | hadaMulti hadaStm;

//else
duendeStm ::= DUENDE cuerpo;

estructura ::= forStmt 
                | doUntilStmt 
                | elfoStm;


//Funciones 

//Llamada de funciones
//hola()
//adios(intx, in)|
//error al poner funcion al final de una expresioncon final de linea ocupa doble final de linea para funcionar
ids ::= operando
    | ids MUERDAGO operando;
    
llamadaNavidenia ::= PERSONA:per ABRECUENTO CIERRACUENTO
                  |  PERSONA:per  ABRECUENTO ids CIERRACUENTO
                  ;

llamadaNavideniaAux ::= llamadaNavidenia FINREGALO;

// Producción del parámetro para la función
// tipo identificador
ayudanteDeSanta ::= t_santas:tst PERSONA:per
                {:
                ArrayList<String> detallesFuncion = listaTablaSimbolos.get(currentHash);
                String nombreParametro = "tipo:param:" + per.toString();

                // Verificar si ya existe un parámetro con el mismo nombre
                boolean parametroYaExiste = detallesFuncion.stream()
                    .anyMatch(param -> param.startsWith(nombreParametro));

                if (!parametroYaExiste) {
                    // Añadir el nuevo parámetro si no existe
                    String nuevoParametro = nombreParametro + ":" + tst.toString();
                    detallesFuncion.add(nuevoParametro);
                } else {
                    // Manejar el caso en que el parámetro con ese nombre ya exista
                    System.err.println("Error Semántico: "+ (cur_token.left+1) + 
                                                ", columna " + (cur_token.right) + " " + "Parámetro '" + per.toString() + "' ya declarado en la función.");
                }
                :}
                ;

// Varios parámetros
ayudaDefFunNav ::= ayudanteDeSanta
                    | ayudaDefFunNav MUERDAGO ayudanteDeSanta;



// Ayuda para la definición de funciones
// function int func3
ayudaDefinirFuncionNavi ::= EMPEZONAVIDAD t_santas:tst PERSONA:per 
                    
                    {:  
                        if (!listaTablaSimbolos.containsKey(per.toString())) {
                            // La función no existe, entonces se agrega
                            currentHash = per.toString();
                            String tipoTabla = "tipo:function:" + tst.toString();
                            ArrayList<String> funcionMain = new ArrayList<String>();
                            funcionMain.add(tipoTabla);
                            listaTablaSimbolos.put(currentHash, funcionMain);

                            // Se verifica si el valor de retorno es apropiado
                            if ((tst.equals("int") || tst.equals("float") || tst.equals("char") || tst.equals("bool"))) {
                                RESULT = "dir:"+tst;
                            } else {
                                System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                                                ", columna " + (cur_token.right) + ": Este tipo de función no es permitido: " + tst);
                                RESULT = "dir:null";
                            }
                        } else {
                            // La función ya existe, se muestra un mensaje de error
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                                            ", columna " + (cur_token.right) + ": Esta función ya existe con este nombre");
                            RESULT = "dir:null";     
                        }
                    :}

                    | EMPEZONAVIDAD t_santas:tst ENTREGAREGALOS:per

                    {:
                        if (listaTablaSimbolos.containsKey("main")) {
                            // Si ya existe un 'main', se muestra un mensaje de error
                            System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                                            ", columna " + (cur_token.right) + ": Solo puede haber un 'main' en el programa");
                            RESULT = "dir:null"; 
                        } else {
                            // Si no existe un 'main', se agrega a la tabla de símbolos
                            currentHash = per.toString(); 
                            String tipoTabla = "tipo:main:" + tst.toString();
                            ArrayList<String> funcionMain = new ArrayList<String>();
                            funcionMain.add(tipoTabla);
                            listaTablaSimbolos.put(currentHash, funcionMain);

                            // Se verifica si el valor de retorno es apropiado
                            if ((tst.equals("int"))) {
                                RESULT = "dir:" + tst;
                            } else {
                                System.err.println("Error semántico en la línea " + (cur_token.left+1) + 
                                                ", columna " + (cur_token.right) + ": Este tipo de función no es permitido: " + tst);
                                RESULT = "dir:null";
                            }
                        }
                    :}

                    ;

// Producción del cuerpo principal de la declaración de la función con parámetros y sin parámetros
// function int func3( )
// function int func3(int 1)
definirFunNav ::=  ayudaDefinirFuncionNavi:defin ABRECUENTO CIERRACUENTO 
                {:
                String[] partesOperando = defin.toString().split(":");
                RESULT = "dir:"+partesOperando[1];
                :}
                | ayudaDefinirFuncionNavi:defin ABRECUENTO ayudaDefFunNav CIERRACUENTO 
                {:
                String[] partesOperando = defin.toString().split(":");
                RESULT = "dir:"+partesOperando[1];
                :}
                | error FINREGALO 
                | error CIERRAREGALO
                | error ABREREGALO
                ;

// Definición completa de la función
bolsanavidenia ::= definirFunNav:defin
                {:
                 String[] partesOperando1 = defin.toString().split(":");
                 RESULT = "dir:" + partesOperando1[1];
                :}
                | definirFunNav:defin cuerpo:cuer               
                {:
                String[] partesOperando1 = defin.toString().split(":");
                String[] partesOperando2 = cuer.toString().split(":");
                if(!(partesOperando1[1].equals(partesOperando2[1]))){
                    System.out.println("Error Semántico en la línea:" + (cur_token.left) + 
                                ", columna " + (cur_token.right) +":"+"El tipo de la función no cumple con su tipo de retorno esperado");
                    RESULT = "dir:" + partesOperando1[1];
                }
                :}
                ;

// Producción del return 
//Return (Return operando;)
envia ::= ENVIA operando:oper FINREGALO
        {:
            String[] partesOperando = oper.toString().split(":");
                    // Se verifica si tipo de la variable
                        if((partesOperando[1].equals("null") || partesOperando[1].equals("string"))){
                           System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                ", columna " + (cur_token.right) +": "  + "Tipo de retorno de la función es nulo, revise si esa variable existe");
                                RESULT = "dir:null"; 
                        }else{ 
                            RESULT = "dir:"+ partesOperando[1];
                            //System.out.println("El tipo de retorno es: " + partesOperando[1]);
                         }
        :}
        ;

// Producción del break
//Break (Break;)
corta ::= CORTA FINREGALO;

// Producción del print
// print: print(operando);
// Sólo puede imprimir literales y operandos de tipo int, float y string
narraNavidad ::= NARRA ABRECUENTO operando:opernarra CIERRACUENTO FINREGALO
                 {:
                String[] partesOperando = opernarra.toString().split(":");
                    if(partesOperando[1].equals("int")||partesOperando[1].equals("float") || partesOperando[1].equals("string")){
                        RESULT = "dir:"+ partesOperando[1];
                        addData(partesOperando[2]);
                        addFunp("\tj bloquePrint"+(getnData()-1)+"\n");
                        generarCodigoMIPS(String.format("bloquePrint"+(getnData()-1)+ ":" + "\n\tli $v0, 4\n" + "\tla $a0, %s\n", ( "m" + (getnData()-1))) +"\tsyscall\n\n");
                        System.out.println("tipo del print correcto");
                    }else{
                        RESULT = "dir:null";
                        System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                ", columna " + (cur_token.right) +": "  + "Tipo del print erróneo, revise su tipo");
                                RESULT = "dir:null"; 
                    }
                :}
               ;
                

// Producción del read
// read(operando)|
// Sólo puede leer operandos y literales de tipo int y float
escuchaNavidad ::= ESCUCHA ABRECUENTO operando:operescucha CIERRACUENTO FINREGALO
                {:
                String[] partesOperando = operescucha.toString().split(":");
                    if(partesOperando[1].equals("int")||(partesOperando[1].equals("float"))){
                        RESULT = "dir:"+ partesOperando[1];
                        System.out.println("tipo del read correcto");
                    }else{
                        RESULT = "dir:null";
                        System.err.println("Error semántico en la línea " + (cur_token.left) + 
                                ", columna " + (cur_token.right) +": "  + "Tipo del read erróneo");
                                RESULT = "dir:null"; 
                    }
                :}
                ;


//Encapsula todas las expresiones para que se puedan colocar dentro de las funciones
poloNorte  ::=  decl_G 
                | creaRegalo
                | creaRegaloAssign
                | narraNavidad:narra
                {:
                    String[] partesOperando = narra.toString().split(":");
                    if(!(partesOperando[1].equals("null"))){
                        RESULT = "dir:"+ partesOperando[1];
                    }else{
                        RESULT = "dir:null";
                    }
                :}
                | estructura
                | envia:env
                {:
                    String[] partesOperando = env.toString().split(":");
                    if(!(partesOperando[1].equals("null"))){
                        RESULT = "dir:"+ partesOperando[1];
                    }else{
                        RESULT = "dir:null";
                    }
                :}
                | exprUni:prUni
                {:
                    String[] partesOperando = prUni.toString().split(":");
                    if(!(partesOperando[1].equals("null"))){
                        RESULT = "dir:"+ partesOperando[1];
                    }else{
                        RESULT = "dir:null";
                    }
                :}
                | escuchaNavidad:escuch
                {:
                    String[] partesOperando = escuch.toString().split(":");
                    if(!(partesOperando[1].equals("null"))){
                        RESULT = "dir:"+ partesOperando[1];
                    }else{
                        RESULT = "dir:null";
                    }
                :}
                | arrayInitialization:arz
                {:
                    if (arz != null) {
                        RESULT = arz;
                    } else {
                        RESULT = "dir:null";
                    }
                :}
                | arrayDeclaration:ard
                {:
                    if (ard != null) {
                        RESULT = ard;
                    } else {
                        RESULT = "dir:null";
                    }
                :}
                | corta
                | llamadaNavideniaAux
                ;

// Varias expresiones
regalo ::= poloNorte:poli1 
            {:
                if (poli1 != null) {
                    RESULT = poli1;
                } else {
                    RESULT = "dir:null";
                }
            :}    
            | regalo:reg poloNorte:poli2
            {:
                RESULT = poli2;
            :} 
            | error FINREGALO
            ;

// Varias funciones juntas
pbolsanavideniaAux ::=  bolsanavidenia
                    | pbolsanavideniaAux bolsanavidenia;


// Símbolo inicial con el que empieza la gramática
navidad ::= {:
                System.out.println("Empieza el asunto");
                :} 
                pbolsanavideniaAux
                {:
                imprimirTablaSimbolos();
                escribirCodigoMIPSEnArchivo();
                System.out.println("Termina el asunto");
                :};

antartica ::= bolsanavidenia | poloNorte;

regaloExtn ::= antartica
            | regaloExtn antartica;